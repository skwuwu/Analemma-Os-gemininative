{
  "Comment": "Analemma OS v3.0 - Distributed Smart StateBag with Race-Condition-Free Parallel Processing",
  "StartAt": "CheckIdempotency",
  "States": {
    "CheckIdempotency": {
      "Type": "Choice",
      "Comment": "üîí MOCK_MODE bypass or DynamoDB check",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.MOCK_MODE",
              "StringEquals": "true"
            },
            {
              "Variable": "$.test_workflow_config",
              "IsPresent": true
            }
          ],
          "Next": "InitializeStateBag"
        }
      ],
      "Default": "VerifyIdempotencyKey"
    },
    "VerifyIdempotencyKey": {
      "Type": "Task",
      "Resource": "arn:aws:states:::dynamodb:getItem",
      "Parameters": {
        "TableName": "${IdempotencyTable}",
        "Key": {
          "idempotency_key": {
            "S.$": "$.idempotency_key"
          }
        },
        "ProjectionExpression": "executionArn, #st",
        "ExpressionAttributeNames": {
          "#st": "status"
        }
      },
      "ResultPath": "$.dynamodb_result",
      "Retry": [
        {
          "ErrorEquals": [
            "DynamoDB.ServiceException",
            "DynamoDB.ThrottlingException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.idempotency_error",
          "Next": "HandleIdempotencyError"
        }
      ],
      "Next": "EvaluateIdempotency"
    },
    "HandleIdempotencyError": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.ALLOW_UNSAFE_EXECUTION",
          "BooleanEquals": true,
          "Next": "InitializeStateBag"
        }
      ],
      "Default": "FailIdempotencyUnavailable"
    },
    "FailIdempotencyUnavailable": {
      "Type": "Fail",
      "Error": "IdempotencyCheckFailed",
      "Cause": "Unable to verify execution uniqueness"
    },
    "EvaluateIdempotency": {
      "Type": "Choice",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.dynamodb_result.Item",
              "IsPresent": true
            },
            {
              "Variable": "$.dynamodb_result.Item.status.S",
              "StringEquals": "RUNNING"
            }
          ],
          "Next": "FailDuplicateExecution"
        },
        {
          "And": [
            {
              "Variable": "$.dynamodb_result.Item",
              "IsPresent": true
            },
            {
              "Variable": "$.dynamodb_result.Item.status.S",
              "StringEquals": "SUCCEEDED"
            }
          ],
          "Next": "SucceedDuplicateExecution"
        }
      ],
      "Default": "InitializeStateBag"
    },
    "FailDuplicateExecution": {
      "Type": "Fail",
      "Error": "DuplicateExecution",
      "Cause": "An execution with the same idempotency key is already running"
    },
    "SucceedDuplicateExecution": {
      "Type": "Succeed"
    },
    "InitializeStateBag": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üéí Smart StateBag Ï¥àÍ∏∞Ìôî - S3 Ìè¨Ïù∏ÌÑ∞ Í∏∞Î∞ò ÏÉÅÌÉú Í¥ÄÎ¶¨",
      "Parameters": {
        "FunctionName": "${InitializeStateDataArn}",
        "Payload.$": "$"
      },
      "ResultSelector": {
        "bag.$": "$.Payload.state_data.bag"
      },
      "ResultPath": "$.state_data",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0,
          "JitterStrategy": "FULL"
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.init_error",
          "Next": "NotifyAndFailInit"
        }
      ],
      "Next": "SelectExecutionMode"
    },
    "NotifyAndFailInit": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "INIT_FAILED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.ownerId",
              "workflowId.$": "$.workflowId",
              "error.$": "$.init_error",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "Next": "FailInitialization"
    },
    "FailInitialization": {
      "Type": "Fail",
      "Error": "InitializationFailed",
      "Cause": "Failed to initialize Smart StateBag"
    },
    "SelectExecutionMode": {
      "Type": "Choice",
      "Comment": "üöÄ ÏÑ∏Í∑∏Î®ºÌä∏ Ïàò/ÎèôÏãúÏÑ± Í∏∞Î∞ò Ïã§Ìñâ Î™®Îìú ÏÑ†ÌÉù",
      "Choices": [
        {
          "Or": [
            {
              "Variable": "$.state_data.bag.total_segments",
              "NumericGreaterThan": 300
            },
            {
              "Variable": "$.state_data.bag.max_concurrency",
              "NumericGreaterThan": 50
            }
          ],
          "Next": "PrepareDistributedExecution"
        }
      ],
      "Default": "NotifyWorkflowStarted"
    },
    "PrepareDistributedExecution": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üì¶ Ï≤≠ÌÅ¨ Î∂ÑÌï† Î∞è S3 ÏóÖÎ°úÎìú - Í∞Å Ï≤≠ÌÅ¨Îäî ÎèÖÎ¶ΩÏ†ÅÏù∏ Í≤∞Í≥º Í≤ΩÎ°ú Ìï†Îãπ",
      "Parameters": {
        "FunctionName": "${PrepareDistributedExecutionArn}",
        "Payload": {
          "state_data.$": "$.state_data.bag",
          "chunk_size": 100,
          "max_chunks": 100,
          "state_bucket": "${WorkflowStateBucket}",
          "assign_independent_paths": true
        }
      },
      "ResultSelector": {
        "chunks_bucket.$": "$.Payload.chunks_bucket",
        "chunks_key.$": "$.Payload.chunks_key",
        "total_chunks.$": "$.Payload.total_chunks",
        "result_prefix.$": "$.Payload.result_prefix"
      },
      "ResultPath": "$.distributed_config",
      "Next": "NotifyDistributedStarted"
    },
    "NotifyDistributedStarted": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "DISTRIBUTED_STARTED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "total_segments.$": "$.state_data.bag.total_segments",
              "total_chunks.$": "$.distributed_config.total_chunks",
              "max_concurrency.$": "$.state_data.bag.max_concurrency",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "CreatePreSnapshot"
    },
    "CreatePreSnapshot": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üì∏ [P1 State Snapshot] Freeze state_data before distributed execution",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "create_snapshot",
          "state_data.$": "$.state_data.bag",
          "snapshot_type": "PRE_DISTRIBUTED",
          "execution_id.$": "$$.Execution.Id"
        }
      },
      "ResultSelector": {
        "snapshot_s3_path.$": "$.Payload.snapshot_s3_path",
        "snapshot_id.$": "$.Payload.snapshot_id"
      },
      "ResultPath": "$.pre_snapshot",
      "Next": "ExecuteDistributedChunks"
    },
    "ExecuteDistributedChunks": {
      "Type": "Map",
      "Comment": "üöÄ [Race-Condition-Free] Í∞Å Ï≤≠ÌÅ¨Í∞Ä ÎèÖÎ¶ΩÏ†ÅÏù∏ S3 Í≤ΩÎ°úÏóê Í≤∞Í≥º Ï†ÄÏû•",
      "ItemSelector": {
        "state_data.$": "$.state_data",
        "chunk_item.$": "$$.Map.Item.Value",
        "chunk_index.$": "$$.Map.Item.Index",
        "result_prefix.$": "$.distributed_config.result_prefix"
      },
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "DISTRIBUTED",
          "ExecutionType": "STANDARD"
        },
        "StartAt": "ProcessChunkWithHydration",
        "States": {
          "ProcessChunkWithHydration": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "üîÑ StateHydratorÍ∞Ä ÎûåÎã§ ÎÇ¥Î∂ÄÏóêÏÑú S3 Î°úÎìú/Ï†ÄÏû• Ï≤òÎ¶¨",
            "Parameters": {
              "FunctionName": "${ProcessSegmentChunkArn}",
              "Payload": {
                "state_data.$": "$.state_data",
                "chunk_item.$": "$.chunk_item",
                "chunk_index.$": "$.chunk_index",
                "result_prefix.$": "$.result_prefix",
                "independent_mode": true
              }
            },
            "ResultSelector": {
              "delta.$": "$.Payload"
            },
            "ResultPath": "$.chunk_result",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 3,
                "MaxAttempts": 5,
                "BackoffRate": 2.0,
                "JitterStrategy": "FULL"
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.chunk_error",
                "Next": "HandleChunkError"
              }
            ],
            "Next": "EvaluateChunkResult"
          },
          "EvaluateChunkResult": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.chunk_result.delta.status",
                "StringEquals": "PAUSED_FOR_HITP",
                "Next": "WaitForChunkCallback"
              },
              {
                "Variable": "$.chunk_result.delta.status",
                "StringEquals": "FAILED",
                "Next": "HandleChunkError"
              }
            ],
            "Default": "ChunkComplete"
          },
          "WaitForChunkCallback": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke.waitForTaskToken",
            "Comment": "‚è∏Ô∏è [HITP] HeartbeatSecondsÎ°ú Î∂ÄÎ™® ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ (24ÏãúÍ∞Ñ)",
            "HeartbeatSeconds": 86400,
            "Parameters": {
              "FunctionName": "${StoreDistributedTaskTokenArn}",
              "Payload": {
                "TaskToken.$": "$$.Task.Token",
                "state_data.$": "$.state_data",
                "chunk_result.$": "$.chunk_result.delta",
                "distributed_context": {
                  "is_child_execution": true,
                  "parent_execution_id.$": "$.state_data.bag.idempotency_key",
                  "chunk_index.$": "$.chunk_index",
                  "paused_segment_id.$": "$.chunk_result.delta.paused_segment_id"
                }
              }
            },
            "ResultPath": "$.callback_result",
            "Catch": [
              {
                "ErrorEquals": [
                  "States.Timeout"
                ],
                "ResultPath": "$.timeout_error",
                "Next": "HandleChunkTimeout"
              }
            ],
            "Next": "ResumeChunkAfterCallback"
          },
          "ResumeChunkAfterCallback": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "üîÑ ÏΩúÎ∞± ÌõÑ Ï§ëÎã® ÏßÄÏ†êÎ∂ÄÌÑ∞ Ïû¨Í∞ú",
            "Parameters": {
              "FunctionName": "${ProcessSegmentChunkArn}",
              "Payload": {
                "state_data.$": "$.state_data",
                "chunk_item.$": "$.chunk_item",
                "chunk_index.$": "$.chunk_index",
                "result_prefix.$": "$.result_prefix",
                "callback_result.$": "$.callback_result",
                "resume_from_segment.$": "$.chunk_result.delta.paused_segment_id",
                "independent_mode": true
              }
            },
            "ResultSelector": {
              "delta.$": "$.Payload"
            },
            "ResultPath": "$.chunk_result",
            "Next": "EvaluateChunkResult"
          },
          "HandleChunkTimeout": {
            "Type": "Pass",
            "Parameters": {
              "chunk_index.$": "$.chunk_index",
              "status": "TIMEOUT",
              "error": "HITP callback timeout after 1 hour"
            },
            "ResultPath": "$.chunk_result.delta",
            "Next": "ChunkComplete"
          },
          "HandleChunkError": {
            "Type": "Pass",
            "Comment": "üõ°Ô∏è Ï≤≠ÌÅ¨ ÏóêÎü¨Î•º Partial FailureÎ°ú Î≥ÄÌôò (AggregatorÏóêÏÑú Ï≤òÎ¶¨)",
            "Parameters": {
              "chunk_index.$": "$.chunk_index",
              "status": "PARTIAL_FAILURE",
              "error.$": "$.chunk_error",
              "result_s3_path": null
            },
            "ResultPath": "$.chunk_result.delta",
            "Next": "ChunkComplete"
          },
          "ChunkComplete": {
            "Type": "Pass",
            "Comment": "‚úÖ Ï≤≠ÌÅ¨ ÏôÑÎ£å - delta_updateÎßå Î∞òÌôò (ÎèÖÎ¶Ω S3 Í≤ΩÎ°úÏóê Ï†ÄÏû•Îê®)",
            "Parameters": {
              "chunk_index.$": "$.chunk_index",
              "status.$": "$.chunk_result.delta.status",
              "result_s3_path.$": "$.chunk_result.delta.result_s3_path",
              "segments_processed.$": "$.chunk_result.delta.segments_processed",
              "execution_time.$": "$.chunk_result.delta.execution_time"
            },
            "End": true
          }
        }
      },
      "ItemReader": {
        "Resource": "arn:aws:states:::s3:getObject",
        "ReaderConfig": {
          "InputType": "JSON"
        },
        "Parameters": {
          "Bucket.$": "$.distributed_config.chunks_bucket",
          "Key.$": "$.distributed_config.chunks_key"
        }
      },
      "ToleratedFailurePercentage": 10,
      "MaxConcurrency": 100,
      "ResultWriter": {
        "Resource": "arn:aws:states:::s3:putObject",
        "Parameters": {
          "Bucket": "${WorkflowStateBucket}",
          "Prefix.$": "States.Format('distributed-results/{}/chunks', $$.Execution.Name)"
        }
      },
      "ResultPath": "$.distributed_results",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.map_error",
          "Next": "HandleDistributedMapError"
        }
      ],
      "Next": "AggregateDistributedResults"
    },
    "HandleDistributedMapError": {
      "Type": "Pass",
      "Comment": "üõ°Ô∏è Preserve bag layer on distributed map failure",
      "Parameters": {
        "distributed_results": [],
        "map_error.$": "$.map_error",
        "state_data": {
          "bag.$": "$.state_data.bag"
        },
        "pre_snapshot.$": "$.pre_snapshot"
      },
      "Next": "AggregateDistributedResults"
    },
    "AggregateDistributedResults": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üîÄ [Map-Reduce + P1 Post-Snapshot] Merge chunk results and verify state continuity",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "aggregate_distributed",
          "state_data.$": "$.state_data.bag",
          "distributed_results.$": "$.distributed_results",
          "pre_snapshot.$": "$.pre_snapshot",
          "map_error.$": "$.map_error",
          "use_s3_results": true,
          "create_post_snapshot": true
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "final_status.$": "$.Payload.final_status",
        "failed_chunks.$": "$.Payload.failed_chunks"
      },
      "ResultPath": "$",
      "Next": "EvaluateDistributedResult"
    },
    "EvaluateDistributedResult": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.final_status",
          "StringEquals": "FAILED",
          "Next": "NotifyAndFail"
        }
      ],
      "Default": "NotifyWorkflowCompleted"
    },
    "NotifyWorkflowStarted": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "üöÄ ÏùºÎ∞ò ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÏãúÏûë ÏïåÎ¶º",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "STARTED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "total_segments.$": "$.state_data.bag.total_segments",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "ExecuteSegment"
    },
    "ExecuteSegment": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üéØ [Standardized] Îã®Ïùº Í∞ùÏ≤¥Î°ú ÌéòÏù¥Î°úÎìú Ï†ÑÎã¨",
      "Parameters": {
        "FunctionName": "${ExecuteSegmentArn}",
        "Payload": {
          "state_data.$": "$.state_data.bag"
        }
      },
      "ResultSelector": {
        "result.$": "$.Payload"
      },
      "ResultPath": "$.execution_result",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 5,
          "MaxAttempts": 6,
          "BackoffRate": 2.0,
          "JitterStrategy": "FULL"
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.execution_result.error",
          "Next": "NotifyAndFail"
        }
      ],
      "Next": "SyncStateData"
    },
    "SyncStateData": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üîÑ [Central Manager] ÏÉÅÌÉú ÎèôÍ∏∞Ìôî + S3 Ïò§ÌîÑÎ°úÎî©",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "sync",
          "state_data.$": "$.state_data.bag",
          "execution_result.$": "$.execution_result.result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "S3.ServiceException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 4,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.sync_error",
          "Next": "NotifyAndFail"
        }
      ],
      "Next": "EvaluateNextAction"
    },
    "EvaluateNextAction": {
      "Type": "Choice",
      "Comment": "üß≠ Îã§Ïùå Ïï°ÏÖò ÎùºÏö∞ÌåÖ",
      "Choices": [
        {
          "Variable": "$.next_action",
          "StringEquals": "FAILED",
          "Next": "NotifyAndFail"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "COMPLETE",
          "Next": "NotifyWorkflowCompleted"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PAUSED_FOR_HITP",
          "Next": "WaitForCallback"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PAUSE",
          "Next": "WaitForCallback"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PARALLEL_GROUP",
          "Next": "ProcessParallelBranches"
        }
      ],
      "Default": "CheckLoopLimit"
    },
    "CheckLoopLimit": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.state_data.bag.loop_counter",
          "NumericGreaterThanPath": "$.state_data.bag.max_loop_iterations",
          "Next": "FailLoopLimitExceeded"
        }
      ],
      "Default": "ExecuteSegment"
    },
    "FailLoopLimitExceeded": {
      "Type": "Fail",
      "Error": "LoopLimitExceeded",
      "CausePath": "States.Format('Exceeded max iterations: {}', $.state_data.bag.max_loop_iterations)"
    },
    "ProcessParallelBranches": {
      "Type": "Map",
      "Comment": "üåø [Pointer Strategy] Distributed parallel branches - pointers only in pending_branches",
      "ItemsPath": "$.state_data.bag.pending_branches",
      "MaxConcurrencyPath": "$.state_data.bag.max_concurrency",
      "ItemSelector": {
        "state_data.$": "$.state_data.bag",
        "branch_pointer.$": "$$.Map.Item.Value",
        "branch_index.$": "$$.Map.Item.Index"
      },
      "ResultSelector": {
        "branches.$": "$"
      },
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "DISTRIBUTED",
          "ExecutionType": "STANDARD"
        },
        "StartAt": "HydrateBranchConfig",
        "States": {
          "HydrateBranchConfig": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "üåø [Pointer Strategy] Hydrate branch config from S3 using branch pointer",
            "Parameters": {
              "FunctionName": "${StateDataManagerArn}",
              "Payload": {
                "action": "hydrate_branch",
                "branch_pointer.$": "$.branch_pointer",
                "branch_index.$": "$.branch_index",
                "state_data.$": "$.state_data"
              }
            },
            "ResultSelector": {
              "branch_config.$": "$.Payload.branch_config",
              "branch_index.$": "$.Payload.branch_index",
              "state_data.$": "$.Payload.state_data"
            },
            "ResultPath": "$",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.TooManyRequestsException",
                  "States.Timeout"
                ],
                "IntervalSeconds": 1,
                "MaxAttempts": 3,
                "BackoffRate": 2.0
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.hydrate_error",
                "Next": "HandleBranchError"
              }
            ],
            "Next": "ExecuteBranchWithHydration"
          },
          "ExecuteBranchWithHydration": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${ExecuteBranchArn}",
              "Payload": {
                "state_data.$": "$.state_data",
                "branch_config.$": "$.branch_config",
                "branch_index.$": "$.branch_index"
              }
            },
            "ResultSelector": {
              "delta.$": "$.Payload"
            },
            "ResultPath": "$.branch_result",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 3,
                "MaxAttempts": 5,
                "BackoffRate": 2.0
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.branch_error",
                "Next": "HandleBranchError"
              }
            ],
            "Next": "EvaluateBranchResult"
          },
          "EvaluateBranchResult": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.branch_result.delta.status",
                "StringEquals": "PAUSED_FOR_HITP",
                "Next": "WaitForBranchCallback"
              }
            ],
            "Default": "BranchComplete"
          },
          "WaitForBranchCallback": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke.waitForTaskToken",
            "HeartbeatSeconds": 86400,
            "Parameters": {
              "FunctionName": "${StoreDistributedTaskTokenArn}",
              "Payload": {
                "TaskToken.$": "$$.Task.Token",
                "state_data.$": "$.state_data",
                "branch_result.$": "$.branch_result.delta"
              }
            },
            "ResultPath": "$.callback_result",
            "Next": "ResumeBranchAfterCallback"
          },
          "ResumeBranchAfterCallback": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${ExecuteBranchArn}",
              "Payload": {
                "state_data.$": "$.state_data",
                "branch_config.$": "$.branch_config",
                "branch_index.$": "$.branch_index",
                "callback_result.$": "$.callback_result",
                "resume_mode": true
              }
            },
            "ResultSelector": {
              "delta.$": "$.Payload"
            },
            "ResultPath": "$.branch_result",
            "Next": "EvaluateBranchResult"
          },
          "HandleBranchError": {
            "Type": "Pass",
            "Parameters": {
              "branch_index.$": "$.branch_index",
              "status": "PARTIAL_FAILURE",
              "error.$": "$.branch_error"
            },
            "ResultPath": "$.branch_result.delta",
            "Next": "BranchComplete"
          },
          "BranchComplete": {
            "Type": "Pass",
            "Parameters": {
              "branch_index.$": "$.branch_index",
              "status.$": "$.branch_result.delta.status",
              "result_s3_path.$": "$.branch_result.delta.result_s3_path"
            },
            "End": true
          }
        }
      },
      "ResultPath": "$.parallel_results",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.map_error",
          "Next": "HandleParallelMapError"
        }
      ],
      "Next": "AggregateParallelResults"
    },
    "HandleParallelMapError": {
      "Type": "Pass",
      "Comment": "üõ°Ô∏è Preserve bag layer on parallel map failure",
      "Parameters": {
        "parallel_results": [],
        "map_error.$": "$.map_error",
        "state_data": {
          "bag.$": "$.state_data.bag"
        }
      },
      "Next": "AggregateParallelResults"
    },
    "AggregateParallelResults": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üîÄ [Fork-Join + P0] Î∏åÎûúÏπò Í≤∞Í≥º Î≥ëÌï© - S3ÏóêÏÑú Î°úÎìú",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "aggregate_branches",
          "state_data.$": "$.state_data.bag",
          "branch_pointers.$": "$.parallel_results.branches",
          "map_error.$": "$.map_error",
          "load_from_s3": true
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Next": "EvaluateNextAction"
    },
    "WaitForCallback": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke.waitForTaskToken",
      "Comment": "‚è∏Ô∏è [HITP] ÏΩúÎ∞± ÎåÄÍ∏∞",
      "HeartbeatSeconds": 86400,
      "Parameters": {
        "FunctionName": "${StoreTaskTokenArn}",
        "Payload": {
          "TaskToken.$": "$$.Task.Token",
          "execution_id.$": "$$.Execution.Id",
          "state_data.$": "$.state_data.bag"
        }
      },
      "ResultPath": "$.callback_result",
      "Next": "MergeCallbackResult"
    },
    "MergeCallbackResult": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "merge_callback",
          "state_data.$": "$.state_data.bag",
          "callback_result.$": "$.callback_result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Next": "EvaluateNextAction"
    },
    "NotifyWorkflowCompleted": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "‚úÖ ÏôÑÎ£å ÏïåÎ¶º",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "COMPLETED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "final_state_s3_path.$": "$.state_data.bag.state_s3_path",
              "total_segments.$": "$.state_data.bag.total_segments",
              "loop_counter.$": "$.state_data.bag.loop_counter",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "PrepareSuccessOutput"
    },
    "PrepareSuccessOutput": {
      "Type": "Pass",
      "Parameters": {
        "status": "SUCCEEDED",
        "execution_id.$": "$$.Execution.Id",
        "ownerId.$": "$.state_data.bag.ownerId",
        "workflowId.$": "$.state_data.bag.workflowId",
        "final_state_s3_path.$": "$.state_data.bag.state_s3_path",
        "total_segments.$": "$.state_data.bag.total_segments",
        "loop_counter.$": "$.state_data.bag.loop_counter",
        "distributed_execution": true
      },
      "Next": "WorkflowSucceeded"
    },
    "WorkflowSucceeded": {
      "Type": "Succeed"
    },
    "NotifyAndFail": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "üõ°Ô∏è [Hardened] Safe failure notification - dumps full context to prevent field reference crashes",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "FAILED",
              "execution_id.$": "$$.Execution.Id",
              "execution_name.$": "$$.Execution.Name",
              "ownerId.$": "$$.Execution.Input.ownerId",
              "workflowId.$": "$$.Execution.Input.workflowId",
              "error_context.$": "States.JsonToString($)",
              "timestamp.$": "$$.State.EnteredTime",
              "debug_hint": "Full execution context dumped in error_context. Check CloudWatch Logs for parsed details."
            }
          }
        ]
      },
      "ResultPath": null,
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": null,
          "Next": "WorkflowFailed"
        }
      ],
      "Next": "WorkflowFailed"
    },
    "WorkflowFailed": {
      "Type": "Fail",
      "Error": "WorkflowExecutionFailed",
      "Cause": "Workflow execution failed"
    }
  }
}