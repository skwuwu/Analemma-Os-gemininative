{
  "id": "MEMORY_LEAK_TEST",
  "name": "Memory Leak Edge Case Test",
  "description": "메모리 누수 검증: State Bag 무한 증식 방지, S3 orphan 객체 정리, 256KB 임계값 처리",
  "version": "1.0.0",
  "test_category": "os_edge_case",
  "nodes": [
    {
      "id": "setup_memory_test",
      "type": "operator",
      "label": "메모리 테스트 초기화",
      "config": {
        "language": "python",
        "code": "import sys\nimport json\n\nstate['memory_test_started'] = True\nstate['initial_state_keys'] = len(state.keys())\nstate['conversation_history'] = []\nstate['loop_iteration'] = 0\nstate['max_loop_iterations'] = 50\nstate['state_size_threshold_kb'] = 200\nstate['bloat_iterations'] = list(range(20))"
      }
    },
    {
      "id": "simulate_state_bloat",
      "type": "for_each",
      "label": "대화 이력 누적 시뮬레이션",
      "config": {
        "input_list_key": "bloat_iterations",
        "max_iterations": 20,
        "output_key": "bloat_results",
        "sub_node_config": {
          "nodes": [
            {
              "id": "add_conversation",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "import json\n\n# 대화 이력 누적 (메모리 누수 시뮬레이션)\nhistory = state.get('conversation_history', [])\niteration = len(history)\n\n# 점점 커지는 메시지 추가\nnew_message = {\n    'iteration': iteration,\n    'user': f'User message {iteration} ' * (iteration + 1),\n    'assistant': f'Assistant response {iteration} with detailed explanation ' * (iteration + 1),\n    'metadata': {'timestamp': iteration, 'tokens': iteration * 100}\n}\n\nhistory.append(new_message)\nstate['conversation_history'] = history\nstate['current_history_size'] = len(json.dumps(history))"
              }
            }
          ],
          "edges": []
        }
      }
    },
    {
      "id": "check_state_size",
      "type": "operator",
      "label": "상태 크기 검사 및 정리",
      "config": {
        "language": "python",
        "code": "import json\nimport sys\n\n# 현재 상태 크기 계산\nstate_json = json.dumps(state, default=str)\nstate_size_bytes = len(state_json.encode('utf-8'))\nstate_size_kb = state_size_bytes / 1024\n\nthreshold_kb = state.get('state_size_threshold_kb', 200)\n\nstate['memory_metrics'] = {\n    'state_size_bytes': state_size_bytes,\n    'state_size_kb': round(state_size_kb, 2),\n    'threshold_kb': threshold_kb,\n    'exceeds_threshold': state_size_kb > threshold_kb,\n    'total_keys': len(state.keys()),\n    'conversation_count': len(state.get('conversation_history', []))\n}\n\n# 임계값 초과 시 자동 요약/정리 트리거 확인\nif state_size_kb > threshold_kb:\n    state['needs_cleanup'] = True\n    state['cleanup_reason'] = f'State size {state_size_kb:.1f}KB exceeds {threshold_kb}KB threshold'"
      }
    },
    {
      "id": "simulate_s3_temp_files",
      "type": "operator",
      "label": "임시 S3 파일 생성 시뮬레이션",
      "config": {
        "language": "python",
        "code": "import uuid\nimport time\n\n# 임시 S3 경로들 생성 (실제로는 생성하지 않고 추적만)\ntemp_s3_paths = []\nfor i in range(5):\n    temp_path = f's3://workflow-states/temp/{uuid.uuid4().hex}/segment_{i}.json'\n    temp_s3_paths.append({\n        'path': temp_path,\n        'created_at': time.time(),\n        'type': 'intermediate_state'\n    })\n\nstate['temp_s3_paths'] = temp_s3_paths\nstate['orphan_candidates'] = len(temp_s3_paths)"
      }
    },
    {
      "id": "gc_simulation",
      "type": "operator",
      "label": "가비지 컬렉터 시뮬레이션",
      "config": {
        "language": "python",
        "code": "import time\n\n# GC 람다가 호출되었다고 가정\ntemp_paths = state.get('temp_s3_paths', [])\ncleaned_count = 0\n\nfor path_info in temp_paths:\n    # 실제로는 S3에서 삭제\n    path_info['cleaned'] = True\n    path_info['cleaned_at'] = time.time()\n    cleaned_count += 1\n\nstate['gc_result'] = {\n    'total_temp_files': len(temp_paths),\n    'cleaned_count': cleaned_count,\n    'gc_triggered': True,\n    'gc_timestamp': time.time()\n}"
      }
    },
    {
      "id": "memory_leak_validator",
      "type": "operator",
      "label": "메모리 누수 검증",
      "config": {
        "language": "python",
        "code": "import json\n\nmemory_metrics = state.get('memory_metrics', {})\ngc_result = state.get('gc_result', {})\n\nvalidation = {\n    'state_size_monitored': 'state_size_kb' in memory_metrics,\n    'threshold_check_performed': 'exceeds_threshold' in memory_metrics,\n    'gc_triggered_on_cleanup': gc_result.get('gc_triggered', False),\n    'temp_files_cleaned': gc_result.get('cleaned_count', 0) == gc_result.get('total_temp_files', 0),\n    'no_orphan_objects': gc_result.get('cleaned_count', 0) > 0\n}\n\nstate_size_kb = memory_metrics.get('state_size_kb', 0)\nthreshold_kb = memory_metrics.get('threshold_kb', 200)\n\n# 추가 검증: StateManager의 자동 오프로딩 감지\nif state_size_kb > threshold_kb:\n    validation['auto_offload_triggered'] = state.get('_state_s3_path') is not None or state.get('needs_cleanup', False)\nelse:\n    validation['auto_offload_triggered'] = True  # 임계값 미만이면 패스\n\nall_passed = all(validation.values())\n\nstate['memory_leak_test_result'] = {\n    'validation_checks': validation,\n    'state_size_kb': state_size_kb,\n    'threshold_kb': threshold_kb,\n    'temp_files_created': gc_result.get('total_temp_files', 0),\n    'temp_files_cleaned': gc_result.get('cleaned_count', 0),\n    'test_passed': all_passed\n}\n\nif all_passed:\n    state['TEST_RESULT'] = f'✅ MEMORY LEAK PREVENTION VERIFIED: State {state_size_kb:.1f}KB, GC cleaned {gc_result.get(\"cleaned_count\", 0)} files'\nelse:\n    failed_checks = [k for k, v in validation.items() if not v]\n    state['TEST_RESULT'] = f'❌ MEMORY LEAK RISK: Failed checks: {failed_checks}'"
      }
    }
  ],
  "edges": [
    {"source": "setup_memory_test", "target": "simulate_state_bloat"},
    {"source": "simulate_state_bloat", "target": "check_state_size"},
    {"source": "check_state_size", "target": "simulate_s3_temp_files"},
    {"source": "simulate_s3_temp_files", "target": "gc_simulation"},
    {"source": "gc_simulation", "target": "memory_leak_validator"}
  ],
  "metadata": {
    "test_features": ["state_size_monitoring", "auto_summarization", "gc_cleanup", "orphan_detection"],
    "expected_behavior": "StateManager should detect bloat and trigger offloading/cleanup",
    "failure_mode": "State grows unbounded or temp S3 files remain after execution"
  }
}
