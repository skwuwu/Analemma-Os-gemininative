{
  "id": "COST_OPTIMIZED_PARALLEL_TEST",
  "name": "Cost Optimized Parallel Scheduler Test",
  "description": "[Enhanced] COST_OPTIMIZED 전략 + 배치 분할 검증 + 토큰 스트레스 테스트",
  "version": "1.0.1",
  "test_category": "cost_guardrail",
  "nodes": [
    {
      "id": "setup",
      "type": "operator",
      "label": "테스트 설정",
      "config": {
        "language": "python",
        "code": "# 10개 문서 (각 100 토큰 추정 = 1,000 토큰/문서)\nstate['documents'] = [f'Long document content {i} ' * 100 for i in range(10)]\n# 15개 쿼리 (각 50 토큰 추정 = 750 토큰)\nstate['queries'] = [f'Complex query {i}' for i in range(15)]\nstate['setup_complete'] = True\nprint(f'Setup: {len(state[\"documents\"])} documents, {len(state[\"queries\"])} queries')"
      }
    },
    {
      "id": "cost_aware_parallel",
      "type": "parallel_group",
      "label": "비용 인지 병렬 그룹 (토큰 스트레스)",
      "resource_policy": {
        "max_concurrent_memory_mb": 2048,
        "max_concurrent_tokens": 5000,
        "max_concurrent_branches": 5,
        "strategy": "COST_OPTIMIZED"
      },
      "branches": [
        {
          "id": "branch_doc_summarize",
          "name": "문서 요약 (토큰 Heavy)",
          "nodes": [
            {
              "id": "doc_foreach",
              "type": "for_each",
              "config": {
                "input_list_key": "documents",
                "output_key": "summaries",
                "sub_node_config": {
                  "nodes": [
                    {
                      "id": "summarize_llm",
                      "type": "llm_chat",
                      "config": {
                        "model": "gemini-2.0-flash",
                        "prompt_template": "Summarize: {{item}}",
                        "output_key": "summary"
                      }
                    }
                  ],
                  "edges": []
                }
              }
            }
          ],
          "edges": []
        },
        {
          "id": "branch_query_process",
          "name": "쿼리 처리 (토큰 Medium)",
          "nodes": [
            {
              "id": "query_llm",
              "type": "llm_chat",
              "config": {
                "model": "gemini-2.0-flash",
                "prompt_template": "Process queries: {{queries}}",
                "output_key": "query_results"
              }
            }
          ],
          "edges": []
        },
        {
          "id": "branch_light_calc",
          "name": "경량 계산",
          "nodes": [
            {
              "id": "calc_code",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "state['calc_result'] = sum(range(1000))"
              }
            }
          ],
          "edges": []
        }
      ]
    },
    {
      "id": "verify",
      "type": "operator",
      "label": "[Critical] 배치 분할 검증",
      "config": {
        "language": "python",
        "code": "import json\n\nprint('[COST_OPTIMIZED VERIFICATION] Checking batch split results')\n\n# ① scheduling_metadata 추출\nmetadata = state.get('scheduling_metadata', {})\nbatch_count = metadata.get('batch_count', 0)\nstrategy = metadata.get('strategy', '')\ntotal_tokens = metadata.get('total_tokens', 0)\nbatch_splits = metadata.get('batch_splits', [])\n\nprint(f'Metadata: {json.dumps(metadata, indent=2)}')\n\n# ② 예상 검증: 토큰 제한(5000)으로 인해 배치 분할이 일어나야 함\n# 10개 문서 * 1000토큰 = 10,000토큰 > 5000 제한 → 최소 2개 배치\nexpected_min_batches = 2  # 10,000 / 5,000 = 2\n\nchecks = [\n    strategy == 'COST_OPTIMIZED',\n    batch_count >= expected_min_batches,\n    total_tokens > 0,\n    isinstance(batch_splits, list),\n    len(batch_splits) >= 1\n]\n\nall_passed = all(checks)\n\nprint(f'Strategy: {strategy} (expected: COST_OPTIMIZED)')\nprint(f'Batch Count: {batch_count} (expected: >={expected_min_batches})')\nprint(f'Total Tokens: {total_tokens}')\nprint(f'Batch Splits: {len(batch_splits)} batches')\nprint(f'All checks passed: {all_passed}')\n\nstate['cost_test_complete'] = True\nstate['branch_count'] = 3\nstate['batch_verification'] = {\n    'strategy': strategy,\n    'batch_count': batch_count,\n    'total_tokens': total_tokens,\n    'expected_min_batches': expected_min_batches,\n    'batch_split_occurred': batch_count >= expected_min_batches,\n    'checks': checks,\n    'all_passed': all_passed\n}\n\nif all_passed:\n    state['TEST_RESULT'] = f'✅ COST_OPTIMIZED SUCCESS: Processed {total_tokens} tokens across {batch_count} batches (limit: 5000)'\n    state['VALIDATION_STATUS'] = 'PASSED'\n    print('✅ Cost optimization validation passed')\nelse:\n    failed_checks = []\n    if strategy != 'COST_OPTIMIZED': failed_checks.append(f'strategy={strategy}')\n    if batch_count < expected_min_batches: failed_checks.append(f'batch_count={batch_count}<{expected_min_batches}')\n    if total_tokens == 0: failed_checks.append('total_tokens=0')\n    \n    state['TEST_RESULT'] = f'❌ COST_OPTIMIZED FAILED: {failed_checks}'\n    state['VALIDATION_STATUS'] = 'FAILED'\n    print(f'❌ Cost optimization validation failed: {failed_checks}')"
      }
    }
  ],
  "edges": [
    {"source": "setup", "target": "cost_aware_parallel"},
    {"source": "cost_aware_parallel", "target": "verify"}
  ],
  "start_node": "setup",
  "metadata": {
    "test_features": [
      "cost_optimized_strategy",
      "token_based_batch_splitting",
      "token_stress_test",
      "scheduling_metadata_verification"
    ],
    "expected_behavior": "Kernel should split 10,000 tokens across multiple batches due to 5,000 token limit",
    "failure_mode": "No batch splitting occurs, all branches run concurrently exceeding token budget"
  }
}
