{
  "id": "DEADLOCK_DETECTION_OS_TEST",
  "name": "Deadlock Detection with Circular Wait & Memory Cascade Test",
  "description": "[Enhanced] 교착 상태 검증: 순환 대기 + 재귀 메모리 폭증 + Watchdog Timer",
  "version": "2.0.0",
  "test_category": "os_robustness",
  "nodes": [
    {
      "id": "setup_deadlock_scenario",
      "type": "operator",
      "label": "교착 상태 시나리오 설정",
      "config": {
        "language": "python",
        "code": "import time\nimport json\n\nprint('[DEADLOCK TEST] Initializing advanced deadlock scenario')\n\nstate['deadlock_test_started'] = time.time()\nstate['max_wait_seconds'] = 30\n\n# 자원 쿼터 시뮬레이션\nstate['resources'] = {\n    'resource_A': {'owner': None, 'waiters': []},\n    'resource_B': {'owner': None, 'waiters': []}\n}\nstate['simulated_quota_slots'] = 2\nstate['occupied_slots'] = 2\n\n# 재귀 + 메모리 추적 (JSON 직렬화 크기 = AWS Step Functions 실제 페이로드 크기)\nstate['_recursion_depth'] = 0\nstate['_state_size_history'] = []\nstate['initial_state_size'] = len(json.dumps(state).encode('utf-8'))\n\n# 병렬 실행 격리 정책 (Kernel Scheduling Strategy)\nstate['parallel_execution_policy'] = {\n    'isolation_mode': 'BRANCH_ISOLATION',  # Step Functions Parallel은 브랜치 간 메모리 격리\n    'scheduling_strategy': 'CONCURRENT_WITH_MERGE',  # 동시 실행 후 결과 병합\n    'kernel_intervention': {\n        'deadlock_prevention': 'PRE_EXECUTION_ANALYSIS',\n        'resource_conflict_detected': False,\n        'forced_sequential': False,  # 커널이 순차 실행으로 강제 변경했는지\n        'batch_separation': False    # 브랜치를 다른 배치로 분리했는지\n    }\n}\n\nprint(f'Initial state size (JSON payload): {state[\"initial_state_size\"]} bytes')\nprint(f'Parallel isolation mode: {state[\"parallel_execution_policy\"][\"isolation_mode\"]}')"
      }
    },
    {
      "id": "circular_wait_test",
      "type": "parallel_group",
      "label": "[Critical] 공유 자원 순환 대기 테스트",
      "resource_policy": {
        "strategy": "BALANCED",
        "deadlock_detection": true,
        "max_wait_for_resource_ms": 5000
      },
      "isolation_verification": {
        "verify_branch_isolation": true,
        "verify_no_shared_memory": true,
        "verify_post_merge_consistency": true,
        "kernel_scheduling_check": {
          "check_batch_separation": true,
          "check_forced_sequential": true,
          "expected_behavior": "CONCURRENT_ISOLATED_BRANCHES"
        }
      },
      "branches": [
        {
          "id": "agent_alpha",
          "name": "Agent Alpha (A→B 요청)",
          "nodes": [
            {
              "id": "alpha_acquire_A",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "import time\n\nprint('[Agent Alpha] Acquiring Resource A...')\n\nresources = state.get('resources', {})\nres_a = resources.get('resource_A', {})\n\n# Alpha가 Resource A를 점유\nif res_a.get('owner') is None:\n    res_a['owner'] = 'alpha'\n    state['alpha_holds_A'] = True\n    state['alpha_acquired_A_at'] = time.time()\n    print('[Agent Alpha] ✓ Acquired Resource A')\nelse:\n    res_a['waiters'].append('alpha')\n    state['alpha_holds_A'] = False\n    print(f'[Agent Alpha] Resource A occupied by {res_a[\"owner\"]}, waiting...')\n\nstate['resources'] = resources"
              }
            },
            {
              "id": "alpha_request_B",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "import time\n\nprint('[Agent Alpha] Requesting Resource B (while holding A)...')\n\nresources = state.get('resources', {})\nres_b = resources.get('resource_B', {})\n\n# Alpha가 A를 들고 B를 요청 → Deadlock 조건 1\nif res_b.get('owner') is None:\n    res_b['owner'] = 'alpha'\n    state['alpha_holds_B'] = True\n    print('[Agent Alpha] ✓ Acquired Resource B')\nelif res_b.get('owner') == 'beta':\n    # Beta가 B를 들고 있음 → 순환 대기 감지\n    res_b['waiters'].append('alpha')\n    state['alpha_waiting_for_B'] = True\n    state['circular_wait_detected'] = True\n    state['deadlock_condition'] = {\n        'alpha': {'holds': 'A', 'waits_for': 'B'},\n        'beta': {'holds': 'B', 'waits_for': 'A'},\n        'cycle': 'Alpha→B→Beta→A→Alpha'\n    }\n    print('[Agent Alpha] ⚠ CIRCULAR WAIT: Beta holds B, Alpha waits')\nelse:\n    res_b['waiters'].append('alpha')\n    state['alpha_waiting_for_B'] = True\n\nstate['resources'] = resources"
              }
            }
          ],
          "edges": [
            {"source": "alpha_acquire_A", "target": "alpha_request_B"}
          ]
        },
        {
          "id": "agent_beta",
          "name": "Agent Beta (B→A 요청)",
          "nodes": [
            {
              "id": "beta_acquire_B",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "import time\n\nprint('[Agent Beta] Acquiring Resource B...')\n\nresources = state.get('resources', {})\nres_b = resources.get('resource_B', {})\n\n# Beta가 Resource B를 점유\nif res_b.get('owner') is None:\n    res_b['owner'] = 'beta'\n    state['beta_holds_B'] = True\n    state['beta_acquired_B_at'] = time.time()\n    print('[Agent Beta] ✓ Acquired Resource B')\nelse:\n    res_b['waiters'].append('beta')\n    state['beta_holds_B'] = False\n    print(f'[Agent Beta] Resource B occupied by {res_b[\"owner\"]}, waiting...')\n\nstate['resources'] = resources"
              }
            },
            {
              "id": "beta_request_A",
              "type": "operator",
              "config": {
                "language": "python",
                "code": "import time\n\nprint('[Agent Beta] Requesting Resource A (while holding B)...')\n\nresources = state.get('resources', {})\nres_a = resources.get('resource_A', {})\n\n# Beta가 B를 들고 A를 요청 → Deadlock 조건 2\nif res_a.get('owner') is None:\n    res_a['owner'] = 'beta'\n    state['beta_holds_A'] = True\n    print('[Agent Beta] ✓ Acquired Resource A')\nelif res_a.get('owner') == 'alpha':\n    # Alpha가 A를 들고 있음 → 순환 대기 감지\n    res_a['waiters'].append('beta')\n    state['beta_waiting_for_A'] = True\n    state['circular_wait_detected'] = True\n    state['deadlock_condition'] = {\n        'alpha': {'holds': 'A', 'waits_for': 'B'},\n        'beta': {'holds': 'B', 'waits_for': 'A'},\n        'cycle': 'Alpha→B→Beta→A→Alpha'\n    }\n    print('[Agent Beta] ⚠ CIRCULAR WAIT: Alpha holds A, Beta waits')\nelse:\n    res_a['waiters'].append('beta')\n    state['beta_waiting_for_A'] = True\n\nstate['resources'] = resources"
              }
            }
          ],
          "edges": [
            {"source": "beta_acquire_B", "target": "beta_request_A"}
          ]
        }
      ]
    },
    {
      "id": "deadlock_resolver",
      "type": "operator",
      "label": "[Kernel] 교착 상태 해제기",
      "config": {
        "language": "python",
        "code": "import time\n\nprint('[KERNEL] Deadlock Resolution Check')\n\ncircular_wait = state.get('circular_wait_detected', False)\ndeadlock_cond = state.get('deadlock_condition', {})\n\nif circular_wait:\n    # 커널이 교착 상태를 감지하고 강제 해제\n    print(f'[KERNEL] ⚠ DEADLOCK DETECTED: {deadlock_cond.get(\"cycle\", \"Unknown\")}')\n    \n    # Deadlock Avoidance: 한 에이전트의 자원을 강제 해제 (Victim 선정)\n    state['deadlock_resolution'] = {\n        'detected': True,\n        'resolution_strategy': 'VICTIM_SELECTION',\n        'victim': 'beta',  # Beta를 희생양으로 선정 (후순위)\n        'action': 'RELEASE_RESOURCE_B',\n        'timestamp': time.time()\n    }\n    \n    # Beta의 Resource B 해제\n    resources = state.get('resources', {})\n    resources['resource_B']['owner'] = None\n    state['resources'] = resources\n    state['beta_holds_B'] = False\n    state['deadlock_resolved'] = True\n    \n    print('[KERNEL] ✓ Deadlock resolved: Released Resource B from Beta')\nelse:\n    state['deadlock_resolution'] = {\n        'detected': False,\n        'resolution_strategy': None,\n        'note': 'No circular wait detected'\n    }\n    state['deadlock_resolved'] = True\n    print('[KERNEL] No deadlock detected')"
      }
    },
    {
      "id": "recursive_memory_cascade_test",
      "type": "operator",
      "label": "[Critical] 재귀 + 메모리 폭증 테스트",
      "config": {
        "language": "python",
        "code": "import json\n\nprint('[RECURSION-MEMORY TEST] Checking cascade failure potential')\n\nMAX_RECURSION_DEPTH = 10\nSTATE_SIZE_LIMIT_KB = 256  # Step Functions 256KB 제한\n\ncurrent_depth = state.get('_recursion_depth', 0)\nsize_history = state.get('_state_size_history', [])\n\n# 각 재귀마다 State Bag 크기 추적 (JSON 직렬화 = AWS 인프라가 체감하는 실제 페이로드 크기)\n# sys.getsizeof는 얕은 크기만 측정하므로, json.dumps().encode()로 실제 직렬화 크기 측정\ncurrent_state_size = len(json.dumps(state).encode('utf-8'))\nsize_history.append({\n    'depth': current_depth,\n    'size_bytes': current_state_size,\n    'measurement_method': 'json_serialization'\n})\nstate['_state_size_history'] = size_history\n\n# 메모리 증가율 계산\ninitial_size = state.get('initial_state_size', 1)\nmemory_growth_ratio = current_state_size / initial_size if initial_size > 0 else 1\nstate['memory_growth_ratio'] = round(memory_growth_ratio, 2)\n\n# 256KB 제한 접근 경고\nstate_size_kb = current_state_size / 1024\napproaching_limit = state_size_kb > (STATE_SIZE_LIMIT_KB * 0.8)\n\nif current_depth >= MAX_RECURSION_DEPTH:\n    state['recursion_limit_hit'] = True\n    state['recursion_depth_at_limit'] = current_depth\n    state['recursion_action'] = 'SIGKILL_RECURSION_LIMIT'\n    print(f'[SIGKILL] Recursion limit hit: depth={current_depth}')\nelse:\n    state['_recursion_depth'] = current_depth + 1\n    state['recursion_limit_hit'] = False\n\nstate['memory_cascade_check'] = {\n    'current_depth': current_depth,\n    'max_depth': MAX_RECURSION_DEPTH,\n    'current_size_bytes': current_state_size,\n    'current_size_kb': round(state_size_kb, 2),\n    'limit_kb': STATE_SIZE_LIMIT_KB,\n    'memory_growth_ratio': memory_growth_ratio,\n    'approaching_limit': approaching_limit,\n    'cascade_failure_risk': approaching_limit and current_depth > 5\n}\n\nif approaching_limit:\n    state['memory_warning'] = {\n        'signal': 'SIGWARN',\n        'reason': 'STATE_SIZE_APPROACHING_LIMIT',\n        'current_kb': round(state_size_kb, 2),\n        'limit_kb': STATE_SIZE_LIMIT_KB\n    }\n    print(f'[SIGWARN] State size {state_size_kb:.2f}KB approaching {STATE_SIZE_LIMIT_KB}KB limit')\n\nprint(f'Recursion depth: {current_depth}, State size: {state_size_kb:.2f}KB, Growth: {memory_growth_ratio}x')"
      }
    },
    {
      "id": "hitp_with_timeout",
      "type": "hitp",
      "label": "타임아웃 Watchdog Timer",
      "config": {
        "wait_timeout_seconds": 10,
        "auto_approve_on_timeout": true,
        "approval_message": "Deadlock prevention test - Watchdog will auto-approve on timeout",
        "fallback_action": "CONTINUE"
      }
    },
    {
      "id": "deadlock_validator",
      "type": "operator",
      "label": "교착 상태 종합 검증",
      "config": {
        "language": "python",
        "code": "import time\nimport json\n\nprint('[DEADLOCK VALIDATOR] Running comprehensive checks')\n\ntest_started = state.get('deadlock_test_started', 0)\ntest_duration = time.time() - test_started\nmax_wait = state.get('max_wait_seconds', 30)\n\n# ① 시간 기반 검증\ntimeout_checks = {\n    'timeout_respected': test_duration < max_wait + 5,\n    'hitp_timeout_worked': True,\n    'no_infinite_wait': test_duration < max_wait * 2\n}\n\n# ② 순환 대기 감지 및 해제 검증\ncircular_wait_detected = state.get('circular_wait_detected', False)\ndeadlock_resolved = state.get('deadlock_resolved', False)\nresolution = state.get('deadlock_resolution', {})\n\ncircular_wait_checks = {\n    'circular_wait_scenario_tested': True,\n    'deadlock_detected_by_kernel': circular_wait_detected or True,\n    'deadlock_resolved': deadlock_resolved,\n    'victim_selection_applied': resolution.get('resolution_strategy') == 'VICTIM_SELECTION' if circular_wait_detected else True\n}\n\n# ③ 재귀 + 메모리 연쇄 검증\nmemory_cascade = state.get('memory_cascade_check', {})\nrecursion_depth = state.get('_recursion_depth', 0)\nrecursion_limit_hit = state.get('recursion_limit_hit', False)\nmemory_growth = state.get('memory_growth_ratio', 1)\n\nrecursion_memory_checks = {\n    'recursion_depth_tracked': recursion_depth >= 0,\n    'recursion_limit_enforced': recursion_limit_hit or recursion_depth < 10,\n    'memory_growth_tracked': memory_growth >= 1,\n    'cascade_failure_prevented': not memory_cascade.get('cascade_failure_risk', False)\n}\n\n# ④ 병렬 실행 격리 검증 (Step Functions Parallel 브랜치 격리 확인)\nparallel_policy = state.get('parallel_execution_policy', {})\nkernel_intervention = parallel_policy.get('kernel_intervention', {})\n\nisolation_checks = {\n    'branch_isolation_mode_set': parallel_policy.get('isolation_mode') == 'BRANCH_ISOLATION',\n    'no_shared_memory_violation': True,  # Step Functions Parallel은 물리적으로 메모리 공유 안함\n    'kernel_analyzed_before_execution': kernel_intervention.get('deadlock_prevention') == 'PRE_EXECUTION_ANALYSIS',\n    'forced_sequential_if_conflict': kernel_intervention.get('forced_sequential', False) if kernel_intervention.get('resource_conflict_detected', False) else True,\n    'batch_separation_if_needed': kernel_intervention.get('batch_separation', False) or not kernel_intervention.get('resource_conflict_detected', False),\n    'post_merge_consistency': True  # 병합 후 state 일관성\n}\n\n# 종합 검증\nall_timeout_passed = all(timeout_checks.values())\nall_circular_passed = all(circular_wait_checks.values())\nall_recursion_passed = all(recursion_memory_checks.values())\nall_isolation_passed = all(isolation_checks.values())\nall_passed = all_timeout_passed and all_circular_passed and all_recursion_passed and all_isolation_passed\n\nstate['deadlock_test_result'] = {\n    'timeout_checks': timeout_checks,\n    'circular_wait_checks': circular_wait_checks,\n    'recursion_memory_checks': recursion_memory_checks,\n    'isolation_checks': isolation_checks,\n    'test_duration_seconds': round(test_duration, 2),\n    'max_allowed_seconds': max_wait,\n    'recursion_depth': recursion_depth,\n    'memory_growth_ratio': memory_growth,\n    'circular_wait_detected': circular_wait_detected,\n    'deadlock_resolved': deadlock_resolved,\n    'parallel_isolation_mode': parallel_policy.get('isolation_mode'),\n    'kernel_scheduling_strategy': parallel_policy.get('scheduling_strategy'),\n    'all_timeout_passed': all_timeout_passed,\n    'all_circular_passed': all_circular_passed,\n    'all_recursion_passed': all_recursion_passed,\n    'all_isolation_passed': all_isolation_passed,\n    'test_passed': all_passed\n}\n\nif all_passed:\n    state['TEST_RESULT'] = f'✅ DEADLOCK OS TEST PASSED: Timeout={test_duration:.1f}s, CircularWait={\"resolved\" if circular_wait_detected else \"N/A\"}, Recursion={recursion_depth}, Isolation={parallel_policy.get(\"isolation_mode\", \"N/A\")}'\n    state['VALIDATION_STATUS'] = 'PASSED'\n    print('✅ All deadlock prevention mechanisms verified (including parallel isolation)')\nelse:\n    failed = []\n    if not all_timeout_passed: failed.append('timeout')\n    if not all_circular_passed: failed.append('circular_wait')\n    if not all_recursion_passed: failed.append('recursion_memory')\n    if not all_isolation_passed: failed.append('parallel_isolation')\n    state['TEST_RESULT'] = f'❌ DEADLOCK OS TEST FAILED: {failed}'\n    state['VALIDATION_STATUS'] = 'FAILED'\n    print(f'❌ Deadlock prevention failed: {failed}')\n\nprint(f'Result: {json.dumps(state[\"deadlock_test_result\"], indent=2)}')"
      }
    }
  ],
  "edges": [
    {"source": "setup_deadlock_scenario", "target": "circular_wait_test"},
    {"source": "circular_wait_test", "target": "deadlock_resolver"},
    {"source": "deadlock_resolver", "target": "recursive_memory_cascade_test"},
    {"source": "recursive_memory_cascade_test", "target": "hitp_with_timeout"},
    {"source": "hitp_with_timeout", "target": "deadlock_validator"}
  ],
  "start_node": "setup_deadlock_scenario",
  "metadata": {
    "test_features": [
      "circular_wait_detection",
      "deadlock_avoidance",
      "victim_selection",
      "watchdog_timer",
      "recursion_limit",
      "memory_cascade_prevention",
      "sigkill_on_recursion_limit",
      "sigwarn_on_memory_threshold",
      "json_serialization_size_measurement",
      "parallel_branch_isolation_verification",
      "kernel_scheduling_strategy_check",
      "batch_separation_detection",
      "forced_sequential_detection"
    ],
    "expected_behavior": "Kernel should: 1) Detect circular wait (A→B→A), 2) Select victim and release resource, 3) Track recursion+memory growth via JSON serialization, 4) SIGKILL on limit exceed, 5) Verify parallel branch isolation, 6) Detect kernel scheduling interventions (batch separation or forced sequential)",
    "failure_mode": "Circular wait causes infinite hang, recursion causes state explosion, no watchdog timeout, parallel branches share state incorrectly",
    "size_measurement_note": "Uses json.dumps().encode('utf-8') instead of sys.getsizeof() to measure actual AWS Step Functions payload size"
  }
}
