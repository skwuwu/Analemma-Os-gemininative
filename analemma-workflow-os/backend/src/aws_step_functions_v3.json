{
  "Comment": "Analemma OS v3.0 - Smart StateBag Orchestrator with Standardized Interfaces",
  "StartAt": "CheckIdempotency",
  "States": {
    "CheckIdempotency": {
      "Type": "Choice",
      "Comment": "üîí [Idempotency Guard] MOCK_MODE bypass or DynamoDB check",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.MOCK_MODE",
              "IsPresent": true
            },
            {
              "Variable": "$.MOCK_MODE",
              "StringEquals": "true"
            },
            {
              "Variable": "$.test_workflow_config",
              "IsPresent": true
            }
          ],
          "Next": "InitializeStateBag"
        }
      ],
      "Default": "VerifyIdempotencyKey"
    },
    "VerifyIdempotencyKey": {
      "Type": "Task",
      "Resource": "arn:aws:states:::dynamodb:getItem",
      "Comment": "Direct SDK: Query idempotency_key from DynamoDB (no Lambda cold start)",
      "Parameters": {
        "TableName": "${IdempotencyTable}",
        "Key": {
          "idempotency_key": {
            "S.$": "$.idempotency_key"
          }
        },
        "ProjectionExpression": "executionArn, #st",
        "ExpressionAttributeNames": {
          "#st": "status"
        }
      },
      "ResultSelector": {
        "existing_arn.$": "$.Item.executionArn.S",
        "existing_status.$": "$.Item.status.S"
      },
      "ResultPath": "$.idempotency_check",
      "Retry": [
        {
          "ErrorEquals": [
            "DynamoDB.ServiceException",
            "DynamoDB.ThrottlingException",
            "States.TaskFailed"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.idempotency_error",
          "Next": "HandleIdempotencyError"
        }
      ],
      "Next": "EvaluateIdempotency"
    },
    "HandleIdempotencyError": {
      "Type": "Choice",
      "Comment": "Allow unsafe execution if explicitly permitted",
      "Choices": [
        {
          "Variable": "$.ALLOW_UNSAFE_EXECUTION",
          "BooleanEquals": true,
          "Next": "InitializeStateBag"
        }
      ],
      "Default": "FailIdempotencyUnavailable"
    },
    "FailIdempotencyUnavailable": {
      "Type": "Fail",
      "Error": "IdempotencyCheckFailed",
      "Cause": "Unable to verify execution uniqueness"
    },
    "EvaluateIdempotency": {
      "Type": "Choice",
      "Comment": "Handle duplicate execution scenarios",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.idempotency_check.existing_arn",
              "IsPresent": true
            },
            {
              "Variable": "$.idempotency_check.existing_status",
              "StringEquals": "RUNNING"
            }
          ],
          "Next": "FailDuplicateExecution"
        },
        {
          "And": [
            {
              "Variable": "$.idempotency_check.existing_arn",
              "IsPresent": true
            },
            {
              "Variable": "$.idempotency_check.existing_status",
              "StringEquals": "SUCCEEDED"
            }
          ],
          "Next": "SucceedDuplicateExecution"
        }
      ],
      "Default": "InitializeStateBag"
    },
    "FailDuplicateExecution": {
      "Type": "Fail",
      "Error": "DuplicateExecution",
      "Cause": "An execution with the same idempotency key is already running"
    },
    "SucceedDuplicateExecution": {
      "Type": "Succeed",
      "Comment": "Idempotent success - execution already completed"
    },
    "InitializeStateBag": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üéí [Smart StateBag] Create initial state_data with S3 pointers and partition_map",
      "Parameters": {
        "FunctionName": "${InitializeStateDataArn}",
        "Payload.$": "$"
      },
      "ResultSelector": {
        "bag.$": "$.Payload.state_data.bag"
      },
      "ResultPath": "$.state_data",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0,
          "JitterStrategy": "FULL"
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.init_error",
          "Next": "NotifyAndFailInit"
        }
      ],
      "Next": "NotifyWorkflowStarted"
    },
    "NotifyAndFailInit": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "Publish initialization failure event",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "INIT_FAILED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.ownerId",
              "workflowId.$": "$.workflowId",
              "error.$": "$.init_error",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "Next": "FailInitialization"
    },
    "FailInitialization": {
      "Type": "Fail",
      "Error": "InitializationFailed",
      "Cause": "Failed to initialize Smart StateBag"
    },
    "NotifyWorkflowStarted": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "üöÄ Fire-and-forget: Workflow start notification",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "STARTED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "total_segments.$": "$.state_data.bag.total_segments",
              "distributed_strategy.$": "$.state_data.bag.distributed_strategy",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": null,
          "Next": "SelectExecutionStrategy"
        }
      ],
      "Next": "SelectExecutionStrategy"
    },
    "SelectExecutionStrategy": {
      "Type": "Choice",
      "Comment": "üöÄ Hybrid Mode: Route based on distributed_strategy",
      "Choices": [
        {
          "Variable": "$.state_data.bag.distributed_strategy",
          "StringEquals": "MAP_REDUCE",
          "Next": "ExecuteMapReduceMode"
        },
        {
          "Variable": "$.state_data.bag.distributed_strategy",
          "StringEquals": "BATCHED",
          "Next": "ExecuteBatchedMode"
        }
      ],
      "Default": "ExecuteSegment"
    },
    "ExecuteMapReduceMode": {
      "Type": "Map",
      "Comment": "üöÄ [Pointer Strategy] MAP_REDUCE with segment pointer hydration",
      "MaxConcurrencyPath": "$.state_data.bag.max_concurrency",
      "ItemsPath": "$.state_data.bag.segment_manifest",
      "Parameters": {
        "segment_pointer.$": "$$.Map.Item.Value",
        "segment_index.$": "$$.Map.Item.Index",
        "state_data.$": "$.state_data.bag",
        "execution_mode": "MAP_REDUCE"
      },
      "Iterator": {
        "StartAt": "HydrateSegmentConfig",
        "States": {
          "HydrateSegmentConfig": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "üåø [Pointer Strategy] Hydrate segment config from S3",
            "Parameters": {
              "FunctionName": "${StateDataManagerArn}",
              "Payload": {
                "action": "hydrate_segment",
                "segment_pointer.$": "$.segment_pointer",
                "segment_index.$": "$.segment_index",
                "state_data.$": "$.state_data"
              }
            },
            "ResultSelector": {
              "segment_config.$": "$.Payload.segment_config",
              "segment_id.$": "$.Payload.segment_id",
              "execution_order.$": "$.Payload.execution_order",
              "state_data.$": "$.Payload.state_data",
              "execution_mode": "MAP_REDUCE"
            },
            "ResultPath": "$",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 1,
                "MaxAttempts": 3,
                "BackoffRate": 2.0
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.hydrate_error",
                "Next": "MapReduceSegmentFailed"
              }
            ],
            "Next": "MapReduceRunner"
          },
          "MapReduceRunner": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${ExecuteSegmentArn}",
              "Payload.$": "$"
            },
            "ResultSelector": {
              "status.$": "$.Payload.status",
              "segment_id.$": "$.Payload.segment_id",
              "output_s3_path.$": "$.Payload.final_state_s3_path"
            },
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 5,
                "MaxAttempts": 10,
                "BackoffRate": 2.0,
                "JitterStrategy": "FULL"
              }
            ],
            "End": true
          },
          "MapReduceSegmentFailed": {
            "Type": "Pass",
            "Parameters": {
              "status": "FAILED",
              "segment_id": "unknown",
              "error_info.$": "$.hydrate_error"
            },
            "End": true
          }
        }
      },
      "ResultSelector": {
        "segment_results.$": "$"
      },
      "ResultPath": "$.execution_result",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.last_error",
          "Next": "HandleMapReduceFailure"
        }
      ],
      "Next": "SyncStateAfterDistributed"
    },
    "ExecuteBatchedMode": {
      "Type": "Map",
      "Comment": "üöÄ BATCHED: Controlled batch processing",
      "MaxConcurrency": 10,
      "ItemsPath": "$.state_data.bag.segment_manifest",
      "Parameters": {
        "segment_config.$": "$$.Map.Item.Value.segment_config",
        "segment_id.$": "$$.Map.Item.Value.segment_id",
        "execution_order.$": "$$.Map.Item.Value.execution_order",
        "dependencies.$": "$$.Map.Item.Value.dependencies",
        "state_data.$": "$.state_data.bag",
        "execution_mode": "BATCHED"
      },
      "Iterator": {
        "StartAt": "BatchedRunner",
        "States": {
          "BatchedRunner": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${ExecuteSegmentArn}",
              "Payload.$": "$"
            },
            "ResultSelector": {
              "status.$": "$.Payload.status",
              "segment_id.$": "$.Payload.segment_id",
              "final_state.$": "$.Payload.final_state"
            },
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 3,
                "MaxAttempts": 5,
                "BackoffRate": 2.0,
                "JitterStrategy": "FULL"
              }
            ],
            "End": true
          }
        }
      },
      "ResultSelector": {
        "segment_results.$": "$"
      },
      "ResultPath": "$.execution_result",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.last_error",
          "Next": "HandleBatchedFailure"
        }
      ],
      "Next": "SyncStateAfterDistributed"
    },
    "HandleMapReduceFailure": {
      "Type": "Pass",
      "Comment": "üõ°Ô∏è Convert MAP_REDUCE failure to partial results for graceful degradation",
      "Parameters": {
        "execution_result": {
          "segment_results": [],
          "partial_failure": true,
          "error_info.$": "$.last_error"
        },
        "state_data": {
          "bag.$": "$.state_data.bag"
        }
      },
      "Next": "SyncStateAfterDistributed"
    },
    "HandleBatchedFailure": {
      "Type": "Pass",
      "Comment": "üõ°Ô∏è Convert BATCHED failure to partial results for graceful degradation",
      "Parameters": {
        "execution_result": {
          "segment_results": [],
          "partial_failure": true,
          "error_info.$": "$.last_error"
        },
        "state_data": {
          "bag.$": "$.state_data.bag"
        }
      },
      "Next": "SyncStateAfterDistributed"
    },
    "SyncStateAfterDistributed": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üîÑ [Central State Manager] Aggregate distributed results",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "aggregate_distributed",
          "state_data.$": "$.state_data.bag",
          "execution_result.$": "$.execution_result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "final_status.$": "$.Payload.final_status"
      },
      "ResultPath": "$",
      "Next": "NotifyWorkflowCompleted"
    },
    "ExecuteSegment": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üéØ [Standardized Interface] Execute single segment, return ExecutionResult",
      "Parameters": {
        "FunctionName": "${ExecuteSegmentArn}",
        "Payload.$": "$"
      },
      "ResultSelector": {
        "result.$": "$.Payload"
      },
      "ResultPath": "$.execution_result",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 5,
          "MaxAttempts": 6,
          "BackoffRate": 2.0,
          "JitterStrategy": "FULL"
        },
        {
          "ErrorEquals": [
            "States.TaskFailed"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "AsyncLLMRequiredException"
          ],
          "ResultPath": "$.execution_result",
          "Next": "HandleAsyncLLM"
        },
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.last_error",
          "Next": "NotifyAndFail"
        }
      ],
      "Next": "SyncStateData"
    },
    "SyncStateData": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "üîÑ [Central State Manager] Single point of state mutation with S3 offloading",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "sync",
          "state_data.$": "$.state_data.bag",
          "execution_result.$": "$.execution_result.result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.TooManyRequestsException",
            "S3.ServiceException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 4,
          "BackoffRate": 2.0,
          "JitterStrategy": "FULL"
        }
      ],
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.last_error",
          "Next": "NotifyAndFail"
        }
      ],
      "Next": "EvaluateNextAction"
    },
    "EvaluateNextAction": {
      "Type": "Choice",
      "Comment": "üß≠ [Router] Determine next step based on execution_result status and outgoing_edges",
      "Choices": [
        {
          "Variable": "$.next_action",
          "StringEquals": "FAILED",
          "Next": "NotifyAndFail"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "HALTED",
          "Next": "NotifyAndFail"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "SIGKILL",
          "Next": "NotifyAndFail"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "COMPLETE",
          "Next": "NotifyWorkflowCompleted"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PAUSED_FOR_HITP",
          "Next": "WaitForHITPCallback"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PAUSE",
          "Next": "WaitForHITPCallback"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PAUSED_FOR_ASYNC_LLM",
          "Next": "HandleAsyncLLM"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "PARALLEL_GROUP",
          "Next": "ProcessParallelBranches"
        },
        {
          "Variable": "$.next_action",
          "StringEquals": "SEQUENTIAL_BRANCH",
          "Next": "ExecuteSegment"
        }
      ],
      "Default": "CheckLoopLimit"
    },
    "CheckLoopLimit": {
      "Type": "Choice",
      "Comment": "[Safety Valve] Prevent infinite loops",
      "Choices": [
        {
          "Variable": "$.state_data.bag.loop_counter",
          "NumericGreaterThanPath": "$.state_data.bag.max_loop_iterations",
          "Next": "FailLoopLimitExceeded"
        }
      ],
      "Default": "ExecuteSegment"
    },
    "FailLoopLimitExceeded": {
      "Type": "Fail",
      "Error": "LoopLimitExceeded",
      "CausePath": "States.Format('Exceeded max iterations: {}', $.state_data.bag.max_loop_iterations)"
    },
    "ProcessParallelBranches": {
      "Type": "Map",
      "Comment": "üåø [Fork] Execute parallel branches with dynamic concurrency - Pointer Strategy",
      "ItemsPath": "$.state_data.bag.pending_branches",
      "MaxConcurrencyPath": "$.state_data.bag.max_concurrency",
      "Parameters": {
        "branch_pointer.$": "$$.Map.Item.Value",
        "branch_index.$": "$$.Map.Item.Index",
        "state_data.$": "$.state_data.bag"
      },
      "ResultSelector": {
        "branches.$": "$"
      },
      "Iterator": {
        "StartAt": "HydrateBranchConfig",
        "States": {
          "HydrateBranchConfig": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "üåø [Pointer Strategy] Hydrate branch config from S3 using branch pointer",
            "Parameters": {
              "FunctionName": "${StateDataManagerArn}",
              "Payload": {
                "action": "hydrate_branch",
                "branch_pointer.$": "$.branch_pointer",
                "branch_index.$": "$.branch_index",
                "state_data.$": "$.state_data"
              }
            },
            "ResultSelector": {
              "branch_config.$": "$.Payload.branch_config",
              "branch_index.$": "$.Payload.branch_index",
              "state_data.$": "$.Payload.state_data"
            },
            "ResultPath": "$",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.TooManyRequestsException",
                  "States.Timeout"
                ],
                "IntervalSeconds": 1,
                "MaxAttempts": 3,
                "BackoffRate": 2.0
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.hydrate_error",
                "Next": "HandleBranchError"
              }
            ],
            "Next": "InitBranchState"
          },
          "InitBranchState": {
            "Type": "Pass",
            "Comment": "Initialize branch with hydrated config from S3",
            "Parameters": {
              "branch_id.$": "States.Format('branch_{}', $.branch_index)",
              "segment_to_run": 0,
              "loop_counter": 0,
              "branch_config.$": "$.branch_config",
              "partition_map.$": "$.branch_config.partition_map",
              "state_data.$": "$.state_data"
            },
            "ResultPath": "$.branch_state",
            "Next": "ExecuteBranchSegment"
          },
          "ExecuteBranchSegment": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${ExecuteSegmentArn}",
              "Payload": {
                "state_data.$": "$.branch_state.state_data",
                "segment_to_run.$": "$.branch_state.segment_to_run",
                "partition_map.$": "$.branch_state.partition_map",
                "branch_id.$": "$.branch_state.branch_id"
              }
            },
            "ResultSelector": {
              "result.$": "$.Payload"
            },
            "ResultPath": "$.execution_result",
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 2,
                "MaxAttempts": 3,
                "BackoffRate": 2.0
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [
                  "States.ALL"
                ],
                "ResultPath": "$.branch_error",
                "Next": "HandleBranchError"
              }
            ],
            "Next": "SyncBranchState"
          },
          "SyncBranchState": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Comment": "Sync branch state - same StateDataManager interface",
            "Parameters": {
              "FunctionName": "${StateDataManagerArn}",
              "Payload": {
                "action": "sync_branch",
                "branch_state.$": "$.branch_state",
                "execution_result.$": "$.execution_result.result"
              }
            },
            "ResultSelector": {
              "branch_state.$": "$.Payload.branch_state",
              "next_action.$": "$.Payload.next_action"
            },
            "ResultPath": "$",
            "Next": "EvaluateBranchNext"
          },
          "EvaluateBranchNext": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.next_action",
                "StringEquals": "COMPLETE",
                "Next": "BranchComplete"
              },
              {
                "Variable": "$.next_action",
                "StringEquals": "FAILED",
                "Next": "HandleBranchError"
              },
              {
                "Variable": "$.next_action",
                "StringEquals": "HALTED",
                "Next": "HandleBranchError"
              }
            ],
            "Default": "CheckBranchLoopLimit"
          },
          "CheckBranchLoopLimit": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.branch_state.loop_counter",
                "NumericGreaterThanPath": "$.branch_state.state_data.max_branch_iterations",
                "Next": "FailBranchLoopLimit"
              }
            ],
            "Default": "ExecuteBranchSegment"
          },
          "FailBranchLoopLimit": {
            "Type": "Fail",
            "Error": "BranchLoopLimitExceeded",
            "Cause": "Branch exceeded maximum iterations"
          },
          "HandleBranchError": {
            "Type": "Pass",
            "Comment": "Convert branch error to partial failure for aggregator",
            "Parameters": {
              "branch_id.$": "$.branch_state.branch_id",
              "status": "PARTIAL_FAILURE",
              "error_info.$": "$.branch_error",
              "final_state_s3_path.$": "$.branch_state.state_data.state_s3_path"
            },
            "End": true
          },
          "BranchComplete": {
            "Type": "Pass",
            "Parameters": {
              "branch_id.$": "$.branch_state.branch_id",
              "status": "COMPLETE",
              "final_state_s3_path.$": "$.execution_result.result.final_state_s3_path",
              "new_history_logs.$": "$.execution_result.result.new_history_logs"
            },
            "End": true
          }
        }
      },
      "ResultPath": "$.parallel_results",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.map_error",
          "Next": "HandleMapError"
        }
      ],
      "Next": "AggregateParallelResults"
    },
    "HandleMapError": {
      "Type": "Pass",
      "Comment": "Convert Map error to aggregatable result while preserving bag layer",
      "Parameters": {
        "parallel_results": [],
        "map_error.$": "$.map_error",
        "state_data": {
          "bag.$": "$.state_data.bag"
        }
      },
      "Next": "AggregateParallelResults"
    },
    "AggregateParallelResults": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "[Join] Merge parallel branch results using Fork-Join pattern (pointer-only input)",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "aggregate_branches",
          "state_data.$": "$.state_data.bag",
          "branch_pointers.$": "$.parallel_results.branches",
          "map_error.$": "$.map_error",
          "load_from_s3": true
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Next": "EvaluateNextAction"
    },
    "WaitForHITPCallback": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke.waitForTaskToken",
      "Comment": "‚è∏[HITP] Store TaskToken and wait for external resume",
      "HeartbeatSeconds": 86400,
      "Parameters": {
        "FunctionName": "${StoreTaskTokenArn}",
        "Payload": {
          "TaskToken.$": "$$.Task.Token",
          "execution_id.$": "$$.Execution.Id",
          "state_data.$": "$.state_data.bag"
        }
      },
      "ResultPath": "$.callback_result",
      "Catch": [
        {
          "ErrorEquals": [
            "States.Timeout",
            "States.HeartbeatTimeout"
          ],
          "ResultPath": "$.last_error",
          "Next": "HandleHITPTimeout"
        }
      ],
      "Next": "MergeCallbackResult"
    },
    "HandleHITPTimeout": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "Notify user about HITP timeout and trigger retry notification",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "HITP_TIMEOUT",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "message": "Human-in-the-loop callback timed out - please respond",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "NotifyAndFail"
    },
    "MergeCallbackResult": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "Merge HITP callback result into state_data",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "merge_callback",
          "state_data.$": "$.state_data.bag",
          "callback_result.$": "$.callback_result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": "$.last_error",
          "Next": "NotifyAndFail"
        }
      ],
      "Next": "EvaluateNextAction"
    },
    "HandleAsyncLLM": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "Notify user about async LLM processing",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "ASYNC_LLM_PROCESSING",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "message": "Large language model processing asynchronously",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "WaitForAsyncLLMCallback"
    },
    "WaitForAsyncLLMCallback": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke.waitForTaskToken",
      "Comment": "‚è∏Wait for async LLM completion",
      "Parameters": {
        "FunctionName": "${AsyncLLMHandlerArn}",
        "Payload": {
          "TaskToken.$": "$$.Task.Token",
          "execution_id.$": "$$.Execution.Id",
          "state_data.$": "$.state_data.bag"
        }
      },
      "ResultPath": "$.async_result",
      "Next": "MergeAsyncResult"
    },
    "MergeAsyncResult": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Comment": "Merge async LLM result into state_data",
      "Parameters": {
        "FunctionName": "${StateDataManagerArn}",
        "Payload": {
          "action": "merge_async",
          "state_data.$": "$.state_data.bag",
          "async_result.$": "$.async_result"
        }
      },
      "ResultSelector": {
        "state_data": {
          "bag.$": "$.Payload.state_data"
        },
        "next_action.$": "$.Payload.next_action"
      },
      "ResultPath": "$",
      "Next": "EvaluateNextAction"
    },
    "NotifyWorkflowCompleted": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "Publish workflow completion event",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "COMPLETED",
              "execution_id.$": "$$.Execution.Id",
              "ownerId.$": "$.state_data.bag.ownerId",
              "workflowId.$": "$.state_data.bag.workflowId",
              "final_state_s3_path.$": "$.state_data.bag.state_s3_path",
              "total_segments.$": "$.state_data.bag.total_segments",
              "loop_counter.$": "$.state_data.bag.loop_counter",
              "start_time.$": "$.state_data.bag.start_time",
              "timestamp.$": "$$.State.EnteredTime"
            }
          }
        ]
      },
      "ResultPath": null,
      "Next": "PrepareSuccessOutput"
    },
    "PrepareSuccessOutput": {
      "Type": "Pass",
      "Comment": "Prepare final output with execution metrics",
      "Parameters": {
        "status": "SUCCEEDED",
        "execution_id.$": "$$.Execution.Id",
        "ownerId.$": "$.state_data.bag.ownerId",
        "workflowId.$": "$.state_data.bag.workflowId",
        "final_state_s3_path.$": "$.state_data.bag.state_s3_path",
        "total_segments.$": "$.state_data.bag.total_segments",
        "loop_counter.$": "$.state_data.bag.loop_counter",
        "start_time.$": "$.state_data.bag.start_time",
        "llm_segments.$": "$.state_data.bag.llm_segments",
        "hitp_segments.$": "$.state_data.bag.hitp_segments"
      },
      "Next": "WorkflowSucceeded"
    },
    "WorkflowSucceeded": {
      "Type": "Succeed",
      "Comment": "‚úÖ Workflow completed successfully"
    },
    "NotifyAndFail": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Comment": "[Hardened] Safe failure notification - dumps full context to avoid field reference crashes",
      "Parameters": {
        "Entries": [
          {
            "EventBusName": "${WorkflowEventBusArn}",
            "Source": "analemma.orchestrator",
            "DetailType": "WorkflowLifecycleEvent",
            "Detail": {
              "event_type": "FAILED",
              "execution_id.$": "$$.Execution.Id",
              "execution_name.$": "$$.Execution.Name",
              "ownerId.$": "$$.Execution.Input.ownerId",
              "workflowId.$": "$$.Execution.Input.workflowId",
              "error_context.$": "States.JsonToString($)",
              "timestamp.$": "$$.State.EnteredTime",
              "debug_hint": "Full execution context dumped in error_context field. Check CloudWatch Logs for parsed details."
            }
          }
        ]
      },
      "ResultPath": null,
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "ResultPath": null,
          "Next": "WorkflowFailed"
        }
      ],
      "Next": "WorkflowFailed"
    },
    "WorkflowFailed": {
      "Type": "Fail",
      "Error": "WorkflowExecutionFailed",
      "Cause": "Workflow execution failed - see event logs for details"
    }
  }
}