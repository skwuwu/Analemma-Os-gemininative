import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { FileJson, Trash2, Play, Loader2, Eye, ChevronRight, Activity, Upload, X, Image, Film, FileText } from 'lucide-react';
import { toast } from 'sonner';
import { WorkflowChat } from './WorkflowChat';
import { CloneInstructionsDialog } from './CloneInstructionsDialog';
import { useWorkflowStore } from '@/lib/workflowStore';
import { useWorkflowApi } from '@/hooks/useWorkflowApi';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { uploadMedia, SUPPORTED_MEDIA_TYPES, MAX_FILE_SIZE_MB, type UploadedMedia } from '@/lib/mediaApi';

import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { useState, useRef, useLayoutEffect, useMemo } from 'react';
import { convertWorkflowToBackendFormat, convertWorkflowFromBackendFormat, type BackendWorkflow } from '@/lib/workflowConverter';

import { TEST_KEYWORD_DESCRIPTIONS, BUILD_TIME_TEST_KEYWORDS } from '@/lib/testConstants';
import { Node, Edge } from '@xyflow/react';
import { parseInitialState } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';

// íƒ€ì… ì •ì˜
interface WorkflowData {
  id?: string;
  workflowId?: string;
  name?: string;
  nodes: Node[];
  edges: Edge[];
  inputs?: Record<string, any>;
  source_file?: string;
  created_at?: string;
}

export const SavedWorkflows = ({
  currentWorkflow,
  onLoadWorkflow,
}: {
  currentWorkflow?: WorkflowData;
  onLoadWorkflow?: (workflow: WorkflowData) => void;
}) => {
  const { clearWorkflow, loadWorkflow, subgraphs } = useWorkflowStore();
  const {
    workflows,
    isLoading,
    hasMoreWorkflows,
    loadMoreWorkflows,
    isLoadingMore,
    saveWorkflowAsync,
    deleteWorkflow,
    runWorkflowAsync,
    isRunning,
    getWorkflowByName,
    isLoadingWorkflow,
    cloneInstructions,
    isCloningInstructions,
  } = useWorkflowApi();

  const [workflowName, setWorkflowName] = useState('');
  const [showWorkflows, setShowWorkflows] = useState(false);
  const savedListRef = useRef<HTMLDivElement | null>(null);

  // ë¡œë“œ ë° ë¯¸ë¦¬ë³´ê¸° ê´€ë ¨ ìƒíƒœ
  const [selectedWorkflow, setSelectedWorkflow] = useState<{ name: string; workflowId?: string; data?: any; metadata?: Record<string, any> } | null>(null);
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showPreviewDialog, setShowPreviewDialog] = useState(false);
  const [previewData, setPreviewData] = useState<WorkflowData | null>(null);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [workflowToDelete, setWorkflowToDelete] = useState<{ id: string; name: string } | null>(null);
  const [showInitialStateDialog, setShowInitialStateDialog] = useState(false);
  const [initialStateText, setInitialStateText] = useState('');
  const [workflowAlias, setWorkflowAlias] = useState('');
  
  // ë¯¸ë””ì–´ ì—…ë¡œë“œ ê´€ë ¨ ìƒíƒœ
  const [uploadedMedia, setUploadedMedia] = useState<UploadedMedia[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  // Clone Instructions Dialog ìƒíƒœ
  const [showCloneDialog, setShowCloneDialog] = useState(false);
  const [savedWorkflowId, setSavedWorkflowId] = useState<string | null>(null);
  const [savedWorkflowName, setSavedWorkflowName] = useState<string>('');

  // ìë™ ìƒì„±ë  ë³„ì¹­ ê³„ì‚°
  const autoGeneratedAlias = useMemo(() => {
    if (workflowAlias.trim()) return null; // ì‚¬ìš©ìê°€ ì§ì ‘ ì…ë ¥í•œ ê²½ìš° í‘œì‹œí•˜ì§€ ì•ŠìŒ
    if (!initialStateText.trim()) return null;
    const firstWord = initialStateText.trim().split(/\s+/)[0];
    return firstWord || 'Workflow';
  }, [workflowAlias, initialStateText]);

  const handleSave = async () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) {
      toast.error('No workflow to save');
      return;
    }

    // subgraphsë¥¼ í¬í•¨í•œ ì™„ì „í•œ ì›Œí¬í”Œë¡œìš° ê°ì²´ ìƒì„±
    const workflowWithSubgraphs = {
      ...currentWorkflow,
      subgraphs: subgraphs || {},
    };

    const config: BackendWorkflow = convertWorkflowToBackendFormat(workflowWithSubgraphs);
    const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
    config.name = name;
    const is_scheduled = false;
    const next_run_time = null;

    try {
      let serverId: string | null = null;
      const isNewWorkflow = !currentWorkflow.id;

      if (currentWorkflow.id) {
        await saveWorkflowAsync({ workflowId: currentWorkflow.id, config, is_scheduled, next_run_time, name } as any);
        serverId = currentWorkflow.id;
      } else {
        const result = await saveWorkflowAsync({ config, is_scheduled, next_run_time, name } as any) as { workflowId?: string; id?: string } | undefined;
        serverId = result?.workflowId || result?.id || null;
      }

      if (onLoadWorkflow) {
        try {
          const fullWorkflowData = { ...currentWorkflow, id: serverId || currentWorkflow.id || crypto.randomUUID(), name };
          onLoadWorkflow(fullWorkflowData);
        } catch (e) { console.warn('Propagate failed', e); }
      }

      // ìƒˆ ì›Œí¬í”Œë¡œìš°ì¸ ê²½ìš° Clone Instructions Dialog í‘œì‹œ
      if (isNewWorkflow && serverId && workflows.length > 0) {
        setSavedWorkflowId(serverId);
        setSavedWorkflowName(name);
        setShowCloneDialog(true);
      }
    } catch (e) {
      console.error('Save failed:', e);
      toast.error('Failed to save workflow');
      return;
    }
    setWorkflowName('');
  };

  // Clone Instructions í•¸ë“¤ëŸ¬
  const handleCloneConfirm = async (sourceWorkflowId: string | null) => {
    if (sourceWorkflowId && savedWorkflowId) {
      try {
        await cloneInstructions({
          sourceWorkflowId,
          targetWorkflowId: savedWorkflowId,
        });
      } catch (e) {
        console.error('Clone instructions failed:', e);
      }
    }
    setShowCloneDialog(false);
    setSavedWorkflowId(null);
    setSavedWorkflowName('');
  };

  // ë¯¸ë””ì–´ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleMediaUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];
    
    // íŒŒì¼ íƒ€ì… ê²€ì¦
    if (!SUPPORTED_MEDIA_TYPES.includes(file.type as any)) {
      toast.error(`ì§€ì›ë˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ${file.type}`);
      return;
    }

    // íŒŒì¼ í¬ê¸° ê²€ì¦
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > MAX_FILE_SIZE_MB) {
      toast.error(`íŒŒì¼ í¬ê¸°ê°€ ${MAX_FILE_SIZE_MB}MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. (${sizeMB.toFixed(1)}MB)`);
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    try {
      const result = await uploadMedia(file, (percent) => {
        setUploadProgress(percent);
      });
      
      setUploadedMedia((prev) => [...prev, result]);
      toast.success(`${file.name} ì—…ë¡œë“œ ì™„ë£Œ`);
    } catch (error) {
      console.error('Media upload failed:', error);
      toast.error(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleRemoveMedia = (index: number) => {
    setUploadedMedia((prev) => prev.filter((_, i) => i !== index));
  };

  const getMediaIcon = (contentType: string) => {
    if (contentType.startsWith('image/')) return <Image className="w-4 h-4" />;
    if (contentType.startsWith('video/')) return <Film className="w-4 h-4" />;
    return <FileText className="w-4 h-4" />;
  };

  const handleDeleteClick = (workflowId: string, workflowName: string) => {
    if (!workflowId) { toast.error('ID missing'); return; }
    setWorkflowToDelete({ id: workflowId, name: workflowName });
    setShowDeleteDialog(true);
  };
  const handleDeleteConfirm = () => { if (workflowToDelete?.id) deleteWorkflow(workflowToDelete.id); setShowDeleteDialog(false); setWorkflowToDelete(null); };
  const handleDeleteCancel = () => { setShowDeleteDialog(false); setWorkflowToDelete(null); };

  const handleRun = () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) { toast.error('No workflow to run'); return; }
    const hasRequestTrigger = !!currentWorkflow.nodes?.some((n: any) => { if (n.type !== 'trigger') return false; return n.data?.triggerType === 'request' || n.data?.blockId === 'request'; });
    if (hasRequestTrigger) {
      try {
        const existing = currentWorkflow.inputs?.user_prompt ?? currentWorkflow.inputs ?? '';
        const prefill = typeof existing === 'string' ? existing : (typeof currentWorkflow.inputs === 'string' ? currentWorkflow.inputs : '');
        setInitialStateText(prefill || '');
      } catch { setInitialStateText(''); }
      setShowInitialStateDialog(true);
      return;
    }
    executeRun(currentWorkflow.inputs || {});
  };

  const executeRun = async (inputs: Record<string, unknown>) => {
    const runWithId = async (id: string) => { try { await runWorkflowAsync({ workflowId: id, inputs }); } catch (e) { console.error('Run failed:', e); } };
    let workflowId = currentWorkflow.id || currentWorkflow.workflowId;
    if (!workflowId) {
      toast.info('Saving workflow before running...');
      try {
        const config: BackendWorkflow = convertWorkflowToBackendFormat(currentWorkflow);
        const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
        config.name = name;
        const result = await saveWorkflowAsync({ config, is_scheduled: false, next_run_time: null, name }) as { workflowId?: string; id?: string } | undefined;
        workflowId = result?.workflowId || result?.id || null;
        if (!workflowId) { toast.error('Failed to obtain ID'); return; }
        if (onLoadWorkflow) onLoadWorkflow({ ...currentWorkflow, id: workflowId, name });
      } catch (e) { toast.error('Auto-save failed'); return; }
    }
    if (!workflowId) { toast.error('ID missing'); return; }
    await runWithId(workflowId as string);
  };

  const fetchWorkflowDetails = async (name: string) => {
    try {
      const detail = await getWorkflowByName(name);
      const config = detail?.config;
      if (!config) throw new Error('Workflow configuration missing');
      return { name, data: config, metadata: { ...detail, workflowId: detail.workflowId } };
    } catch (error) {
      console.error('Failed to fetch details:', error);
      toast.error(`Failed to load: ${name}`);
      throw error;
    }
  };

  // [ìˆ˜ì •] ë¯¸ë¦¬ë³´ê¸° ëª¨ë“œ í•¸ë“¤ëŸ¬
  const handleViewWorkflow = async (workflow: { name: string; workflowId?: string }) => {
    try {
      const details = await fetchWorkflowDetails(workflow.name);
      const frontendWorkflow = convertWorkflowFromBackendFormat(details.data);
      setSelectedWorkflow(workflow);
      setPreviewData({ ...frontendWorkflow, id: details.metadata.workflowId, name: workflow.name });
      setShowPreviewDialog(true);
    } catch (error) { /* handled in fetchWorkflowDetails */ }
  };

  // [ìˆ˜ì •] ë”ë¸” í´ë¦­ì€ ë°”ë¡œ ë¡œë“œ í™•ì¸ì°½
  const handleWorkflowDoubleClick = (workflow: { name: string; workflowId?: string }) => {
    setSelectedWorkflow(workflow);
    setShowLoadDialog(true);
  };

  const handleLoadConfirm = async () => {
    const targetWorkflow = selectedWorkflow || (previewData ? { name: previewData.name || '', workflowId: previewData.id } : null);
    if (targetWorkflow) {
      try {
        let workflowData;
        if (previewData && previewData.name === targetWorkflow.name) {
          workflowData = { data: convertWorkflowToBackendFormat(previewData), metadata: { workflowId: previewData.id } };
        } else if (selectedWorkflow?.data) {
          workflowData = selectedWorkflow;
        } else {
          workflowData = await fetchWorkflowDetails(targetWorkflow.name);
        }

        const frontendWorkflow = convertWorkflowFromBackendFormat(workflowData.data);

        clearWorkflow();
        loadWorkflow(frontendWorkflow);

        if (onLoadWorkflow) {
          const fullWorkflowData = { ...frontendWorkflow, id: targetWorkflow.workflowId, name: targetWorkflow.name };
          onLoadWorkflow(fullWorkflowData);
        }

        toast.success(`Loaded workflow: ${targetWorkflow.name}`);
      } catch (error) {
        console.error('Failed to load workflow:', error);
      }
    }
    setShowLoadDialog(false);
    setShowPreviewDialog(false);
    setSelectedWorkflow(null);
    setPreviewData(null);
  };

  const handleLoadCancel = () => { setShowLoadDialog(false); setSelectedWorkflow(null); };
  const handlePreviewClose = () => { setShowPreviewDialog(false); setPreviewData(null); setSelectedWorkflow(null); };

  const handleInitialStateCancel = () => { 
    setShowInitialStateDialog(false); 
    setInitialStateText(''); 
    setWorkflowAlias(''); 
    setUploadedMedia([]); // ë¯¸ë””ì–´ ì´ˆê¸°í™”
  };
  const handleInitialStateConfirm = async () => {
    const userInput = (initialStateText ?? '').trim();
    const inputs = parseInitialState(userInput, currentWorkflow);
    let finalAlias = workflowAlias.trim();
    if (!finalAlias && userInput) {
      // ë³„ì¹­ì´ ì—†ìœ¼ë©´ initial stateì˜ ì²« ë‹¨ì–´ë¥¼ ì‚¬ìš©
      const firstWord = userInput.split(/\s+/)[0];
      finalAlias = firstWord || 'Workflow';
    }
    if (finalAlias) {
      inputs.workflow_alias = finalAlias;
    }
    
    // ì—…ë¡œë“œëœ ë¯¸ë””ì–´ URL ì¶”ê°€
    if (uploadedMedia.length > 0) {
      const mediaUrls = uploadedMedia.map((m) => m.s3_url);
      // ë‹¨ì¼ ë¯¸ë””ì–´ì¸ ê²½ìš° ë¬¸ìì—´ë¡œ, ë³µìˆ˜ì¸ ê²½ìš° ë°°ì—´ë¡œ
      if (mediaUrls.length === 1) {
        inputs.media_url = mediaUrls[0];
      } else {
        inputs.media_urls = mediaUrls;
      }
      // ëª¨ë“  ë¯¸ë””ì–´ ë©”íƒ€ë°ì´í„°ë„ í¬í•¨
      inputs._uploaded_media = uploadedMedia.map((m) => ({
        filename: m.filename,
        s3_url: m.s3_url,
        content_type: m.content_type,
        size_bytes: m.size_bytes,
      }));
    }
    
    setShowInitialStateDialog(false);
    setInitialStateText('');
    setWorkflowAlias('');
    setUploadedMedia([]); // ë¯¸ë””ì–´ ì´ˆê¸°í™”
    await executeRun(inputs);
  };

  useLayoutEffect(() => { if (!showWorkflows) return; try { if (savedListRef.current) savedListRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch { } }, [showWorkflows]);

  return (
    <div className="h-full bg-card border-l border-border p-4 flex flex-col">
      <h2 className="text-lg font-bold mb-4 text-foreground">Saved Workflows</h2>

      <div className="space-y-2 mb-4">
        <Input placeholder="Workflow name (optional)" value={workflowName} onChange={(e) => setWorkflowName(e.target.value)} className="h-9 text-sm" />
        <Button onClick={handleSave} className="w-full bg-primary hover:bg-primary/90" disabled={isLoading}>Save Current</Button>
        <Button onClick={handleRun} variant="secondary" className="w-full" disabled={isRunning}>{isRunning ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" />Running...</> : <><Play className="w-4 h-4 mr-2" />Run Workflow</>}</Button>
        <Button onClick={() => setShowWorkflows(!showWorkflows)} variant="outline" className="w-full"><Eye className="w-4 h-4 mr-2" />{showWorkflows ? 'Hide' : 'View My Workflows'}</Button>
      </div>

      {showWorkflows && (
        <div ref={savedListRef}>
          <ScrollArea className="flex-1 mb-4">
            <div className="space-y-2">
              {isLoading ? (
                <div className="text-center py-8 text-muted-foreground text-sm"><Loader2 className="w-4 h-4 mx-auto mb-2 animate-spin" /> Loading workflows...</div>
              ) : workflows.length === 0 ? (
                <div className="text-center py-8 text-muted-foreground text-sm">No saved workflows yet</div>
              ) : (
                workflows.map((workflow) => (
                  <div key={workflow.workflowId || workflow.name} className="p-3 rounded-lg border border-border bg-secondary hover:bg-secondary/80 transition-colors cursor-pointer group" onDoubleClick={() => handleWorkflowDoubleClick(workflow)}>
                    <div className="flex items-start justify-between">
                      <div className="flex items-start gap-2 flex-1">
                        <FileJson className="w-4 h-4 text-primary mt-0.5" />
                        <div className="flex-1 min-w-0">
                          <div className="font-medium text-sm text-foreground truncate">{workflow.name}</div>
                          <div className="text-xs text-muted-foreground flex items-center gap-1 group-hover:text-foreground/70 transition-colors">Double-click to load<ChevronRight className="w-3 h-3" /></div>
                        </div>
                      </div>
                      <div className="flex gap-1">
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); handleViewWorkflow(workflow); }} className="h-8 w-8 p-0"><Eye className="w-3 h-3" /></Button>
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); if (workflow.workflowId) handleDeleteClick(workflow.workflowId, workflow.name); else toast.error('Cannot delete: Workflow ID missing'); }} className="h-8 w-8 p-0 hover:bg-destructive/20" disabled={!workflow.workflowId}><Trash2 className="w-3 h-3 text-destructive" /></Button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
            {hasMoreWorkflows && (<div className="pt-3"><Button onClick={() => loadMoreWorkflows().catch(() => undefined)} variant="ghost" className="w-full" disabled={isLoadingMore}>{isLoadingMore ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : 'Load more workflows'}</Button></div>)}
          </ScrollArea>
        </div>
      )}



      <div className="h-64 border-t border-border"><WorkflowChat onWorkflowUpdate={onLoadWorkflow} /></div>

      {/* 1. Preview Dialog (ìƒˆë¡œ ì¶”ê°€ë¨) */}
      <AlertDialog open={showPreviewDialog} onOpenChange={setShowPreviewDialog}>
        <AlertDialogContent className="max-w-2xl">
          <AlertDialogHeader>
            <div className="flex items-center justify-between">
              <AlertDialogTitle className="flex items-center gap-2"><FileJson className="w-5 h-5 text-primary" />Preview: {selectedWorkflow?.name}</AlertDialogTitle>
              {previewData && (<Badge variant="outline" className="text-xs font-normal">ID: {previewData.id?.slice(0, 8)}...</Badge>)}
            </div>
            <AlertDialogDescription>Review details before loading. Loading will replace your current canvas.</AlertDialogDescription>
          </AlertDialogHeader>

          {previewData ? (
            <div className="grid grid-cols-2 gap-4 py-4">
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border">
                  <h4 className="text-sm font-semibold mb-2 flex items-center gap-2"><Activity className="w-4 h-4" /> Statistics</h4>
                  <div className="text-sm space-y-1 text-muted-foreground">
                    <p>Nodes: <span className="text-foreground font-medium">{previewData.nodes.length}</span></p>
                    <p>Edges: <span className="text-foreground font-medium">{previewData.edges.length}</span></p>
                    {previewData.created_at && (
                      <p className="pt-1 mt-1 border-t border-border/50 text-xs flex items-center gap-1">
                        Created:
                        <span className="text-foreground font-medium">{new Date(previewData.created_at).toLocaleDateString()}</span>
                      </p>
                    )}
                  </div>
                </div>
              </div>
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border h-full">
                  <h4 className="text-sm font-semibold mb-2">Input Configuration</h4>
                  <pre className="text-xs bg-background p-2 rounded border overflow-auto max-h-[100px]">{JSON.stringify(previewData.inputs || {}, null, 2)}</pre>
                </div>
              </div>
              <div className="col-span-2">
                <h4 className="text-sm font-semibold mb-2">Structure Preview</h4>
                <div className="flex flex-wrap gap-2">
                  {previewData.nodes.slice(0, 10).map((node: any) => (<Badge key={node.id} variant="secondary" className="text-xs">{node.type}</Badge>))}
                  {previewData.nodes.length > 10 && <span className="text-xs text-muted-foreground">+{previewData.nodes.length - 10} more</span>}
                </div>
              </div>
            </div>
          ) : (
            <div className="py-8 flex justify-center"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
          )}

          <AlertDialogFooter>
            <AlertDialogCancel onClick={handlePreviewClose}>Close</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={!previewData}>Load to Canvas</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 2. Load Confirm Dialog (ê¸°ì¡´ ìœ ì§€ - ë”ë¸”í´ë¦­ ì‹œ ì‚¬ìš©) */}
      <AlertDialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Load Workflow</AlertDialogTitle>
            <AlertDialogDescription>Loading "{selectedWorkflow?.name}" will clear the current canvas and replace it with the saved workflow. Any unsaved changes will be lost. Are you sure you want to continue?</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleLoadCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={isLoadingWorkflow}>{isLoadingWorkflow ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Loading...</> : 'Load Workflow'}</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 3. Delete Dialog (ê¸°ì¡´ ìœ ì§€) */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Workflow</AlertDialogTitle>
            <AlertDialogDescription>Are you sure you want to delete "{workflowToDelete?.name}"? This action cannot be undone.</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleDeleteCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive hover:bg-destructive/90">Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 4. Initial State Dialog (ë¯¸ë””ì–´ ì—…ë¡œë“œ ê¸°ëŠ¥ ì¶”ê°€) */}
      <AlertDialog open={showInitialStateDialog} onOpenChange={setShowInitialStateDialog}>
        <AlertDialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <AlertDialogHeader>
            <AlertDialogTitle>Run: Initial Prompt</AlertDialogTitle>
            <AlertDialogDescription>Enter a natural-language prompt to start the workflow.</AlertDialogDescription>
          </AlertDialogHeader>
          <div className="mt-2 space-y-4">
            <div>
              <label className="text-sm font-semibold mb-2 block">Workflow Alias (Optional)</label>
              <Input placeholder='e.g. "Stock Analysis - Tech Sector"' value={workflowAlias} onChange={(e) => setWorkflowAlias(e.target.value)} className="w-full text-sm" />
              {autoGeneratedAlias && (
                <p className="text-xs text-muted-foreground mt-1">
                  If not specified, will be saved as: <code className="bg-secondary px-1 py-0.5 rounded text-xs">{autoGeneratedAlias}</code>
                </p>
              )}
            </div>
            <div>
              <label className="text-sm font-semibold mb-2 block">Initial Prompt</label>
              <Textarea placeholder='e.g. "ë‚´ êµ¬ê¸€ ë“œë¼ì´ë¸Œ ìš”ì•½í•´ì¤˜"' value={initialStateText} onChange={(e) => setInitialStateText(e.target.value)} className="min-h-[120px] w-full text-sm" />
            </div>
            
            {/* ğŸ“ ë¯¸ë””ì–´ ì—…ë¡œë“œ ì„¹ì…˜ */}
            <div className="border-t pt-4">
              <label className="text-sm font-semibold mb-2 block">ğŸ“ Media Attachments (Optional)</label>
              <p className="text-xs text-muted-foreground mb-3">
                ì´ë¯¸ì§€, ë¹„ë””ì˜¤, PDF íŒŒì¼ì„ ì²¨ë¶€í•˜ë©´ ì›Œí¬í”Œë¡œìš°ì—ì„œ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ìµœëŒ€ {MAX_FILE_SIZE_MB}MB)
              </p>
              
              {/* ì—…ë¡œë“œ ë²„íŠ¼ */}
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleMediaUpload}
                accept={SUPPORTED_MEDIA_TYPES.join(',')}
                className="hidden"
              />
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full mb-3"
              >
                {isUploading ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ì—…ë¡œë“œ ì¤‘... {uploadProgress}%
                  </>
                ) : (
                  <>
                    <Upload className="w-4 h-4 mr-2" />
                    íŒŒì¼ ì²¨ë¶€í•˜ê¸°
                  </>
                )}
              </Button>
              
              {/* ì—…ë¡œë“œëœ íŒŒì¼ ëª©ë¡ */}
              {uploadedMedia.length > 0 && (
                <div className="space-y-2">
                  {uploadedMedia.map((media, index) => (
                    <div 
                      key={`${media.filename}-${index}`}
                      className="flex items-center justify-between p-2 bg-secondary rounded-md text-sm"
                    >
                      <div className="flex items-center gap-2 overflow-hidden">
                        {getMediaIcon(media.content_type)}
                        <span className="truncate max-w-[200px]" title={media.filename}>
                          {media.filename}
                        </span>
                        <span className="text-xs text-muted-foreground whitespace-nowrap">
                          ({(media.size_bytes / 1024 / 1024).toFixed(1)}MB)
                        </span>
                      </div>
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => handleRemoveMedia(index)}
                        className="h-6 w-6 p-0 hover:bg-destructive/20"
                      >
                        <X className="w-4 h-4" />
                      </Button>
                    </div>
                  ))}
                </div>
              )}
            </div>
            
            <div>
              <h4 className="text-sm font-semibold mb-2">Supported Test Keywords</h4>
              <div className="grid grid-cols-1 gap-2 max-h-40 overflow-y-auto">
                {BUILD_TIME_TEST_KEYWORDS.map((keyword) => (
                  <div key={keyword} className="flex justify-between items-center p-2 bg-secondary rounded text-sm">
                    <code className="font-mono text-primary">{keyword}</code>
                    <span className="text-muted-foreground text-xs ml-2">
                      {TEST_KEYWORD_DESCRIPTIONS[keyword as keyof typeof TEST_KEYWORD_DESCRIPTIONS] || 'í…ŒìŠ¤íŠ¸ í‚¤ì›Œë“œ'}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleInitialStateCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleInitialStateConfirm} className="bg-primary hover:bg-primary/90">Run</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 5. Clone Instructions Dialog (ìƒˆë¡œ ì¶”ê°€ë¨) */}
      <CloneInstructionsDialog
        open={showCloneDialog}
        onOpenChange={setShowCloneDialog}
        workflows={workflows}
        onConfirm={handleCloneConfirm}
        isCloning={isCloningInstructions}
        targetWorkflowName={savedWorkflowName}
      />
    </div>
  );
};
