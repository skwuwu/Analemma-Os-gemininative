import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { FileJson, Trash2, Play, Loader2, Eye, ChevronRight, Activity, Upload, X, Image, Film, FileText, Sparkles } from 'lucide-react';
import { toast } from 'sonner';
import { fetchAuthSession } from '@aws-amplify/auth';
import { CloneInstructionsDialog } from './CloneInstructionsDialog';
import { PlanBriefingModal } from './PlanBriefingModal';
import { usePlanBriefing } from '@/hooks/useBriefingAndCheckpoints';
import { useWorkflowStore } from '@/lib/workflowStore';
import { useWorkflowApi } from '@/hooks/useWorkflowApi';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { uploadMedia, SUPPORTED_MEDIA_TYPES, MAX_FILE_SIZE_MB, type UploadedMedia } from '@/lib/mediaApi';

import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { useState, useRef, useLayoutEffect, useMemo } from 'react';
import { convertWorkflowToBackendFormat, convertWorkflowFromBackendFormat, type BackendWorkflow } from '@/lib/workflowConverter';
import { useCodesignStore } from '@/lib/codesignStore';

import { TEST_KEYWORD_DESCRIPTIONS, BUILD_TIME_TEST_KEYWORDS } from '@/lib/testConstants';
import { Node, Edge } from '@xyflow/react';
import { parseInitialState } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';

// ÌÉÄÏûÖ Ï†ïÏùò
interface WorkflowData {
  id?: string;
  workflowId?: string;
  name?: string;
  nodes: Node[];
  edges: Edge[];
  inputs?: Record<string, any>;
  source_file?: string;
  created_at?: string;
}

export const SavedWorkflows = ({
  currentWorkflow,
  onLoadWorkflow,
}: {
  currentWorkflow?: WorkflowData;
  onLoadWorkflow?: (workflow: WorkflowData) => void;
}) => {
  const { clearWorkflow, loadWorkflow, subgraphs } = useWorkflowStore();
  const { auditIssues, requestAudit, requestSimulation } = useCodesignStore();
  const {
    workflows,
    isLoading,
    hasMoreWorkflows,
    loadMoreWorkflows,
    isLoadingMore,
    saveWorkflowAsync,
    deleteWorkflow,
    runWorkflowAsync,
    isRunning,
    getWorkflowByName,
    isLoadingWorkflow,
    cloneInstructions,
    isCloningInstructions,
  } = useWorkflowApi();

  const [workflowName, setWorkflowName] = useState('');
  const [showWorkflows, setShowWorkflows] = useState(false);
  const savedListRef = useRef<HTMLDivElement | null>(null);

  // Î°úÎìú Î∞è ÎØ∏Î¶¨Î≥¥Í∏∞ Í¥ÄÎ†® ÏÉÅÌÉú
  const [selectedWorkflow, setSelectedWorkflow] = useState<{ name: string; workflowId?: string; data?: any; metadata?: Record<string, any> } | null>(null);
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showPreviewDialog, setShowPreviewDialog] = useState(false);
  const [previewData, setPreviewData] = useState<WorkflowData | null>(null);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [workflowToDelete, setWorkflowToDelete] = useState<{ id: string; name: string } | null>(null);
  const [showInitialStateDialog, setShowInitialStateDialog] = useState(false);
  const [initialStateText, setInitialStateText] = useState('');
  const [workflowAlias, setWorkflowAlias] = useState('');

  // ÎØ∏ÎîîÏñ¥ ÏóÖÎ°úÎìú Í¥ÄÎ†® ÏÉÅÌÉú
  const [uploadedMedia, setUploadedMedia] = useState<UploadedMedia[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  // Clone Instructions Dialog ÏÉÅÌÉú
  const [showCloneDialog, setShowCloneDialog] = useState(false);
  const [savedWorkflowId, setSavedWorkflowId] = useState<string | null>(null);
  const [savedWorkflowName, setSavedWorkflowName] = useState<string>('');

  // Plan Briefing ÏÉÅÌÉú
  const [briefingOpen, setBriefingOpen] = useState(false);
  const planBriefing = usePlanBriefing({
    onSuccess: () => {
      setBriefingOpen(true);
      toast.success('Workflow analysis complete');
    },
    onError: (error) => {
      toast.error(`Analysis failed: ${error.message}`);
    },
  });

  // ÏûêÎèô ÏÉùÏÑ±Îê† Î≥ÑÏπ≠ Í≥ÑÏÇ∞
  const autoGeneratedAlias = useMemo(() => {
    if (workflowAlias.trim()) return null; // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÅÏ†ë ÏûÖÎ†•Ìïú Í≤ΩÏö∞ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
    if (!initialStateText.trim()) return null;
    const firstWord = initialStateText.trim().split(/\s+/)[0];
    return firstWord || 'Workflow';
  }, [workflowAlias, initialStateText]);

  const handleSave = async () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) {
      toast.error('No workflow to save');
      return;
    }

    // 1Îã®Í≥Ñ: Î®ºÏ†Ä Î∞±ÏóîÎìú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    console.log('üîÑ [SavedWorkflows] Step 1: Converting to backend format...');
    const workflowWithSubgraphs = {
      ...currentWorkflow,
      subgraphs: subgraphs || {},
    };
    const config: BackendWorkflow = convertWorkflowToBackendFormat(workflowWithSubgraphs);
    
    // üêõ ÎîîÎ≤ÑÍπÖ: Î≥ÄÌôòÎêú ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÌôïÏù∏
    console.log('[SaveWorkflow] Converted workflow config:', JSON.stringify(config, null, 2));
    
    const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
    config.name = name;

    // 2Îã®Í≥Ñ: Î≥ÄÌôòÎêú Î∞±ÏóîÎìú ÏõåÌÅ¨ÌîåÎ°úÏö∞Î°ú Í≤ÄÏ¶ù (ÏÑ†ÌÉùÏ†Å - Í≤ΩÍ≥†Îßå)
    console.log('‚úÖ [SavedWorkflows] Step 2: Validating converted workflow...');
    
    try {
      // Get auth token
      const session = await fetchAuthSession();
      const idToken = session.tokens?.idToken?.toString();
      
      // Audit Ï≤¥ÌÅ¨ (Î≥ÄÌôòÎêú Î∞±ÏóîÎìú ÏõåÌÅ¨ÌîåÎ°úÏö∞Î°ú)
      await requestAudit(
        { nodes: config.nodes, edges: config.edges },
        idToken
      );

      // Ïã¨Í∞ÅÌïú Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ Í≤ΩÍ≥†Îßå Î°úÍ∑∏ (Î≥ÄÌôò ÌõÑÏù¥ÎØÄÎ°ú ÎåÄÎ∂ÄÎ∂Ñ Ìï¥Í≤∞Îê®)
      const criticalIssues = auditIssues.filter(issue => issue.level === 'error');
      if (criticalIssues.length > 0) {
        console.log('‚ö†Ô∏è [SavedWorkflows] Validation warnings after conversion:', {
          issueCount: criticalIssues.length,
          issues: criticalIssues.map(issue => ({
            level: issue.level,
            message: issue.message,
            nodeId: issue.nodeId,
            category: issue.category
          })),
          convertedConfig: {
            name: name,
            nodeCount: config.nodes?.length || 0,
            edgeCount: config.edges?.length || 0,
            nodes: config.nodes?.map((n: any) => ({
              id: n.id,
              type: n.type,
              label: n.label,
              hasConfig: !!n.config,
              configKeys: n.config ? Object.keys(n.config) : []
            })),
            edges: config.edges?.map((e: any) => ({
              source: e.source,
              target: e.target,
              type: e.type
            })),
            fullConfig: config
          }
        });
        
        // Î≥ÄÌôò ÌõÑ Í≤ÄÏ¶ù Í≤ΩÍ≥†Îäî UIÏóê ÌëúÏãúÌïòÏßÄ ÏïäÏùå (ÏΩòÏÜî Î°úÍ∑∏Îßå)
      }

      // Simulation Ïã§Ìñâ (Í≤ΩÎ°ú Í≤ÄÏ¶ù - ÏÑ†ÌÉùÏ†Å)
      const simulationResult = await requestSimulation(
        { nodes: config.nodes, edges: config.edges },
        idToken
      );

      if (simulationResult && !simulationResult.success) {
        console.log('‚ö†Ô∏è [SavedWorkflows] Workflow has logical issues (see audit panel)');
      } else {
        console.log('‚úÖ [SavedWorkflows] Validation passed');
      }
    } catch (error) {
      console.error('[SavedWorkflows] Validation failed:', error);
      // Í≤ÄÏ¶ù Ïã§Ìå®Ìï¥ÎèÑ Ï†ÄÏû•ÏùÄ ÌóàÏö© (Î°úÍ∑∏Îßå)
    }

    // 3Îã®Í≥Ñ: Ï†ÄÏû• Ïã§Ìñâ
    console.log('üíæ [SavedWorkflows] Step 3: Saving to backend...');
    const is_scheduled = false;
    const next_run_time = null;

    console.log('üì§ [SaveWorkflow] Attempting to save workflow...', {
      workflowId: currentWorkflow.id,
      workflowName: name,
      nodeCount: config.nodes?.length || 0,
      edgeCount: config.edges?.length || 0,
      hasSubgraphs: Object.keys(config.subgraphs || {}).length > 0,
    });

    try {
      let serverId: string | null = null;
      const isNewWorkflow = !currentWorkflow.id;

      if (currentWorkflow.id) {
        await saveWorkflowAsync({ workflowId: currentWorkflow.id, config, is_scheduled, next_run_time, name } as any);
        serverId = currentWorkflow.id;
      } else {
        const result = await saveWorkflowAsync({ config, is_scheduled, next_run_time, name } as any) as { workflowId?: string; id?: string } | undefined;
        serverId = result?.workflowId || result?.id || null;
      }

      if (onLoadWorkflow) {
        try {
          const fullWorkflowData = { ...currentWorkflow, id: serverId || currentWorkflow.id || crypto.randomUUID(), name };
          onLoadWorkflow(fullWorkflowData);
        } catch (e) { console.warn('Propagate failed', e); }
      }

      // ÏÉà ÏõåÌÅ¨ÌîåÎ°úÏö∞Ïù∏ Í≤ΩÏö∞ Clone Instructions Dialog ÌëúÏãú
      if (isNewWorkflow && serverId && workflows.length > 0) {
        setSavedWorkflowId(serverId);
        setSavedWorkflowName(name);
        setShowCloneDialog(true);
      }
    } catch (e) {
      console.error('‚ùå [SaveWorkflow] Save failed!', {
        error: e,
        errorMessage: e instanceof Error ? e.message : String(e),
        errorStack: e instanceof Error ? e.stack : undefined,
        attemptedConfig: {
          name: name,
          nodeCount: config.nodes?.length || 0,
          edgeCount: config.edges?.length || 0,
          nodes: config.nodes?.map((n: any) => ({
            id: n.id,
            type: n.type,
            label: n.label,
            hasConfig: !!n.config,
            configKeys: n.config ? Object.keys(n.config) : []
          })),
          edges: config.edges?.map((e: any) => ({
            source: e.source,
            target: e.target,
            type: e.type
          })),
          fullConfig: config
        }
      });
      toast.error(`Failed to save workflow: ${e instanceof Error ? e.message : 'Unknown error'}`);
      return;
    }
    setWorkflowName('');
  };

  // Clone Instructions Ìï∏Îì§Îü¨
  const handleCloneConfirm = async (sourceWorkflowId: string | null) => {
    if (sourceWorkflowId && savedWorkflowId) {
      try {
        await cloneInstructions({
          sourceWorkflowId,
          targetWorkflowId: savedWorkflowId,
        });
      } catch (e) {
        console.error('Clone instructions failed:', e);
      }
    }
    setShowCloneDialog(false);
    setSavedWorkflowId(null);
    setSavedWorkflowName('');
  };

  // ÎØ∏ÎîîÏñ¥ ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleMediaUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];

    // ÌååÏùº ÌÉÄÏûÖ Í≤ÄÏ¶ù
    if (!SUPPORTED_MEDIA_TYPES.includes(file.type as any)) {
      toast.error(`ÏßÄÏõêÎêòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§: ${file.type}`);
      return;
    }

    // ÌååÏùº ÌÅ¨Í∏∞ Í≤ÄÏ¶ù
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > MAX_FILE_SIZE_MB) {
      toast.error(`ÌååÏùº ÌÅ¨Í∏∞Í∞Ä ${MAX_FILE_SIZE_MB}MBÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§. (${sizeMB.toFixed(1)}MB)`);
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    try {
      const result = await uploadMedia(file, (percent) => {
        setUploadProgress(percent);
      });

      setUploadedMedia((prev) => [...prev, result]);
      toast.success(`${file.name} ÏóÖÎ°úÎìú ÏôÑÎ£å`);
    } catch (error) {
      console.error('Media upload failed:', error);
      toast.error(`ÏóÖÎ°úÎìú Ïã§Ìå®: ${error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}`);
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleRemoveMedia = (index: number) => {
    setUploadedMedia((prev) => prev.filter((_, i) => i !== index));
  };

  const getMediaIcon = (contentType: string) => {
    if (contentType.startsWith('image/')) return <Image className="w-4 h-4" />;
    if (contentType.startsWith('video/')) return <Film className="w-4 h-4" />;
    return <FileText className="w-4 h-4" />;
  };

  const handleDeleteClick = (workflowId: string, workflowName: string) => {
    if (!workflowId) { toast.error('ID missing'); return; }
    setWorkflowToDelete({ id: workflowId, name: workflowName });
    setShowDeleteDialog(true);
  };
  const handleDeleteConfirm = () => { if (workflowToDelete?.id) deleteWorkflow(workflowToDelete.id); setShowDeleteDialog(false); setWorkflowToDelete(null); };
  const handleDeleteCancel = () => { setShowDeleteDialog(false); setWorkflowToDelete(null); };

  const handleRun = () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) { toast.error('No workflow to run'); return; }
    const hasRequestTrigger = !!currentWorkflow.nodes?.some((n: any) => { if (n.type !== 'trigger') return false; return n.data?.triggerType === 'request' || n.data?.blockId === 'request'; });
    if (hasRequestTrigger) {
      try {
        const existing = currentWorkflow.inputs?.user_prompt ?? currentWorkflow.inputs ?? '';
        const prefill = typeof existing === 'string' ? existing : (typeof currentWorkflow.inputs === 'string' ? currentWorkflow.inputs : '');
        setInitialStateText(prefill || '');
      } catch { setInitialStateText(''); }
      setShowInitialStateDialog(true);
      return;
    }
    executeRun(currentWorkflow.inputs || {});
  };

  const executeRun = async (inputs: Record<string, unknown>) => {
    const runWithId = async (id: string) => { try { await runWorkflowAsync({ workflowId: id, inputs }); } catch (e) { console.error('Run failed:', e); } };
    let workflowId = currentWorkflow.id || currentWorkflow.workflowId;
    if (!workflowId) {
      toast.info('Saving workflow before running...');
      try {
        const config: BackendWorkflow = convertWorkflowToBackendFormat(currentWorkflow);
        const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
        config.name = name;
        const result = await saveWorkflowAsync({ config, is_scheduled: false, next_run_time: null, name }) as { workflowId?: string; id?: string } | undefined;
        workflowId = result?.workflowId || result?.id || null;
        if (!workflowId) { toast.error('Failed to obtain ID'); return; }
        if (onLoadWorkflow) onLoadWorkflow({ ...currentWorkflow, id: workflowId, name });
      } catch (e) { toast.error('Auto-save failed'); return; }
    }
    if (!workflowId) { toast.error('ID missing'); return; }
    await runWithId(workflowId as string);
  };

  const fetchWorkflowDetails = async (name: string) => {
    try {
      const detail = await getWorkflowByName(name);
      const config = detail?.config;
      if (!config) throw new Error('Workflow configuration missing');
      return { name, data: config, metadata: { ...detail, workflowId: detail.workflowId } };
    } catch (error) {
      console.error('Failed to fetch details:', error);
      toast.error(`Failed to load: ${name}`);
      throw error;
    }
  };

  // [ÏàòÏ†ï] ÎØ∏Î¶¨Î≥¥Í∏∞ Î™®Îìú Ìï∏Îì§Îü¨
  const handleViewWorkflow = async (workflow: { name: string; workflowId?: string }) => {
    try {
      const details = await fetchWorkflowDetails(workflow.name);
      const frontendWorkflow = convertWorkflowFromBackendFormat(details.data);
      setSelectedWorkflow(workflow);
      setPreviewData({ ...frontendWorkflow, id: details.metadata.workflowId, name: workflow.name });
      setShowPreviewDialog(true);
    } catch (error) { /* handled in fetchWorkflowDetails */ }
  };

  // [ÏàòÏ†ï] ÎçîÎ∏î ÌÅ¥Î¶≠ÏùÄ Î∞îÎ°ú Î°úÎìú ÌôïÏù∏Ï∞Ω
  const handleWorkflowDoubleClick = (workflow: { name: string; workflowId?: string }) => {
    setSelectedWorkflow(workflow);
    setShowLoadDialog(true);
  };

  const handleLoadConfirm = async () => {
    const targetWorkflow = selectedWorkflow || (previewData ? { name: previewData.name || '', workflowId: previewData.id } : null);
    if (targetWorkflow) {
      try {
        let workflowData;
        if (previewData && previewData.name === targetWorkflow.name) {
          workflowData = { data: convertWorkflowToBackendFormat(previewData), metadata: { workflowId: previewData.id } };
        } else if (selectedWorkflow?.data) {
          workflowData = selectedWorkflow;
        } else {
          workflowData = await fetchWorkflowDetails(targetWorkflow.name);
        }

        const frontendWorkflow = convertWorkflowFromBackendFormat(workflowData.data);

        clearWorkflow();
        loadWorkflow(frontendWorkflow);

        if (onLoadWorkflow) {
          const fullWorkflowData = { ...frontendWorkflow, id: targetWorkflow.workflowId, name: targetWorkflow.name };
          onLoadWorkflow(fullWorkflowData);
        }

        toast.success(`Loaded workflow: ${targetWorkflow.name}`);
      } catch (error) {
        console.error('Failed to load workflow:', error);
      }
    }
    setShowLoadDialog(false);
    setShowPreviewDialog(false);
    setSelectedWorkflow(null);
    setPreviewData(null);
  };

  const handleLoadCancel = () => { setShowLoadDialog(false); setSelectedWorkflow(null); };
  const handlePreviewClose = () => { setShowPreviewDialog(false); setPreviewData(null); setSelectedWorkflow(null); };

  const handleInitialStateCancel = () => {
    setShowInitialStateDialog(false);
    setInitialStateText('');
    setWorkflowAlias('');
    setUploadedMedia([]); // ÎØ∏ÎîîÏñ¥ Ï¥àÍ∏∞Ìôî
  };
  const handleInitialStateConfirm = async () => {
    const userInput = (initialStateText ?? '').trim();
    const inputs = parseInitialState(userInput, currentWorkflow);
    let finalAlias = workflowAlias.trim();
    if (!finalAlias && userInput) {
      // Î≥ÑÏπ≠Ïù¥ ÏóÜÏúºÎ©¥ initial stateÏùò Ï≤´ Îã®Ïñ¥Î•º ÏÇ¨Ïö©
      const firstWord = userInput.split(/\s+/)[0];
      finalAlias = firstWord || 'Workflow';
    }
    if (finalAlias) {
      inputs.workflow_alias = finalAlias;
    }

    // ÏóÖÎ°úÎìúÎêú ÎØ∏ÎîîÏñ¥ URL Ï∂îÍ∞Ä
    if (uploadedMedia.length > 0) {
      const mediaUrls = uploadedMedia.map((m) => m.s3_url);
      // Îã®Ïùº ÎØ∏ÎîîÏñ¥Ïù∏ Í≤ΩÏö∞ Î¨∏ÏûêÏó¥Î°ú, Î≥µÏàòÏù∏ Í≤ΩÏö∞ Î∞∞Ïó¥Î°ú
      if (mediaUrls.length === 1) {
        inputs.media_url = mediaUrls[0];
      } else {
        inputs.media_urls = mediaUrls;
      }
      // Î™®Îì† ÎØ∏ÎîîÏñ¥ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÎèÑ Ìè¨Ìï®
      inputs._uploaded_media = uploadedMedia.map((m) => ({
        filename: m.filename,
        s3_url: m.s3_url,
        content_type: m.content_type,
        size_bytes: m.size_bytes,
      }));
    }

    setShowInitialStateDialog(false);
    setInitialStateText('');
    setWorkflowAlias('');
    setUploadedMedia([]); // ÎØ∏ÎîîÏñ¥ Ï¥àÍ∏∞Ìôî
    await executeRun(inputs);
  };

  useLayoutEffect(() => { if (!showWorkflows) return; try { if (savedListRef.current) savedListRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch { } }, [showWorkflows]);

  return (
    <div className="h-full bg-card border-l border-border p-4 flex flex-col">
      <h2 className="text-lg font-bold mb-4 text-foreground">Saved Workflows</h2>

      <div className="space-y-2 mb-4">
        <Input placeholder="Workflow name (optional)" value={workflowName} onChange={(e) => setWorkflowName(e.target.value)} className="h-9 text-sm" />
        <Button onClick={handleSave} className="w-full bg-primary hover:bg-primary/90" disabled={isLoading}>Save Current</Button>
        <Button 
          onClick={async () => {
            if (!currentWorkflow?.nodes?.length) {
              toast.error('No workflow to analyze');
              return;
            }
            await planBriefing.generate({
              workflow_config: {
                name: workflowName || 'Current Workflow',
                nodes: currentWorkflow.nodes,
                edges: currentWorkflow.edges,
              },
              initial_statebag: {},
              use_llm: false,
            });
          }}
          variant="outline" 
          className="w-full border-blue-500/50 hover:bg-blue-500/10 hover:border-blue-500" 
          disabled={planBriefing.isLoading || !currentWorkflow?.nodes?.length}
        >
          {planBriefing.isLoading ? (
            <><Loader2 className="w-4 h-4 mr-2 animate-spin" />Analyzing...</>
          ) : (
            <><Sparkles className="w-4 h-4 mr-2" />Analyze Plan</>
          )}
        </Button>
        <Button onClick={handleRun} variant="secondary" className="w-full" disabled={isRunning}>{isRunning ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" />Running...</> : <><Play className="w-4 h-4 mr-2" />Run Workflow</>}</Button>
        <Button onClick={() => setShowWorkflows(!showWorkflows)} variant="outline" className="w-full"><Eye className="w-4 h-4 mr-2" />{showWorkflows ? 'Hide' : 'View My Workflows'}</Button>
      </div>

      {showWorkflows && (
        <div ref={savedListRef}>
          <ScrollArea className="flex-1 mb-4">
            <div className="space-y-2">
              {isLoading ? (
                <div className="text-center py-8 text-muted-foreground text-sm"><Loader2 className="w-4 h-4 mx-auto mb-2 animate-spin" /> Loading workflows...</div>
              ) : workflows.length === 0 ? (
                <div className="text-center py-8 text-muted-foreground text-sm">No saved workflows yet</div>
              ) : (
                workflows.map((workflow) => (
                  <div key={workflow.workflowId || workflow.name} className="p-3 rounded-lg border border-border bg-secondary hover:bg-secondary/80 transition-colors cursor-pointer group" onDoubleClick={() => handleWorkflowDoubleClick(workflow)}>
                    <div className="flex items-start justify-between">
                      <div className="flex items-start gap-2 flex-1">
                        <FileJson className="w-4 h-4 text-primary mt-0.5" />
                        <div className="flex-1 min-w-0">
                          <div className="font-medium text-sm text-foreground truncate">{workflow.name}</div>
                          <div className="text-xs text-muted-foreground flex items-center gap-1 group-hover:text-foreground/70 transition-colors">Double-click to load<ChevronRight className="w-3 h-3" /></div>
                        </div>
                      </div>
                      <div className="flex gap-1">
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); handleViewWorkflow(workflow); }} className="h-8 w-8 p-0"><Eye className="w-3 h-3" /></Button>
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); if (workflow.workflowId) handleDeleteClick(workflow.workflowId, workflow.name); else toast.error('Cannot delete: Workflow ID missing'); }} className="h-8 w-8 p-0 hover:bg-destructive/20" disabled={!workflow.workflowId}><Trash2 className="w-3 h-3 text-destructive" /></Button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
            {hasMoreWorkflows && (<div className="pt-3"><Button onClick={() => loadMoreWorkflows().catch(() => undefined)} variant="ghost" className="w-full" disabled={isLoadingMore}>{isLoadingMore ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : 'Load more workflows'}</Button></div>)}
          </ScrollArea>
        </div>
      )}

      {/* 1. Preview Dialog (ÏÉàÎ°ú Ï∂îÍ∞ÄÎê®) */}
      <AlertDialog open={showPreviewDialog} onOpenChange={setShowPreviewDialog}>
        <AlertDialogContent className="max-w-2xl">
          <AlertDialogHeader>
            <div className="flex items-center justify-between">
              <AlertDialogTitle className="flex items-center gap-2"><FileJson className="w-5 h-5 text-primary" />Preview: {selectedWorkflow?.name}</AlertDialogTitle>
              {previewData && (<Badge variant="outline" className="text-xs font-normal">ID: {previewData.id?.slice(0, 8)}...</Badge>)}
            </div>
            <AlertDialogDescription>Review details before loading. Loading will replace your current canvas.</AlertDialogDescription>
          </AlertDialogHeader>

          {previewData ? (
            <div className="grid grid-cols-2 gap-4 py-4">
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border">
                  <h4 className="text-sm font-semibold mb-2 flex items-center gap-2"><Activity className="w-4 h-4" /> Statistics</h4>
                  <div className="text-sm space-y-1 text-muted-foreground">
                    <p>Nodes: <span className="text-foreground font-medium">{previewData.nodes.length}</span></p>
                    <p>Edges: <span className="text-foreground font-medium">{previewData.edges.length}</span></p>
                    {previewData.created_at && (
                      <p className="pt-1 mt-1 border-t border-border/50 text-xs flex items-center gap-1">
                        Created:
                        <span className="text-foreground font-medium">{new Date(previewData.created_at).toLocaleDateString()}</span>
                      </p>
                    )}
                  </div>
                </div>
              </div>
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border h-full">
                  <h4 className="text-sm font-semibold mb-2">Input Configuration</h4>
                  <pre className="text-xs bg-background p-2 rounded border overflow-auto max-h-[100px]">{JSON.stringify(previewData.inputs || {}, null, 2)}</pre>
                </div>
              </div>
              <div className="col-span-2">
                <h4 className="text-sm font-semibold mb-2">Structure Preview</h4>
                <div className="flex flex-wrap gap-2">
                  {previewData.nodes.slice(0, 10).map((node: any) => (<Badge key={node.id} variant="secondary" className="text-xs">{node.type}</Badge>))}
                  {previewData.nodes.length > 10 && <span className="text-xs text-muted-foreground">+{previewData.nodes.length - 10} more</span>}
                </div>
              </div>
            </div>
          ) : (
            <div className="py-8 flex justify-center"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
          )}

          <AlertDialogFooter>
            <AlertDialogCancel onClick={handlePreviewClose}>Close</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={!previewData}>Load to Canvas</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 2. Load Confirm Dialog (Í∏∞Ï°¥ Ïú†ÏßÄ - ÎçîÎ∏îÌÅ¥Î¶≠ Ïãú ÏÇ¨Ïö©) */}
      <AlertDialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Load Workflow</AlertDialogTitle>
            <AlertDialogDescription>Loading "{selectedWorkflow?.name}" will clear the current canvas and replace it with the saved workflow. Any unsaved changes will be lost. Are you sure you want to continue?</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleLoadCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={isLoadingWorkflow}>{isLoadingWorkflow ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Loading...</> : 'Load Workflow'}</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 3. Delete Dialog (Í∏∞Ï°¥ Ïú†ÏßÄ) */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Workflow</AlertDialogTitle>
            <AlertDialogDescription>Are you sure you want to delete "{workflowToDelete?.name}"? This action cannot be undone.</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleDeleteCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive hover:bg-destructive/90">Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 4. Initial State Dialog (ÎØ∏ÎîîÏñ¥ ÏóÖÎ°úÎìú Í∏∞Îä• Ï∂îÍ∞Ä) */}
      <AlertDialog open={showInitialStateDialog} onOpenChange={setShowInitialStateDialog}>
        <AlertDialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <AlertDialogHeader>
            <AlertDialogTitle>Run: Initial Prompt</AlertDialogTitle>
            <AlertDialogDescription>Enter a natural-language prompt to start the workflow.</AlertDialogDescription>
          </AlertDialogHeader>
          <div className="mt-2 space-y-4">
            <div>
              <label className="text-sm font-semibold mb-2 block">Workflow Alias (Optional)</label>
              <Input placeholder='e.g. "Stock Analysis - Tech Sector"' value={workflowAlias} onChange={(e) => setWorkflowAlias(e.target.value)} className="w-full text-sm" />
              {autoGeneratedAlias && (
                <p className="text-xs text-muted-foreground mt-1">
                  If not specified, will be saved as: <code className="bg-secondary px-1 py-0.5 rounded text-xs">{autoGeneratedAlias}</code>
                </p>
              )}
            </div>
            <div>
              <label className="text-sm font-semibold mb-2 block">Initial Prompt</label>
              <Textarea placeholder='e.g. "Summarize my Google Drive documents"' value={initialStateText} onChange={(e) => setInitialStateText(e.target.value)} className="min-h-[120px] w-full text-sm" />
            </div>

            {/* üìÅ Media Upload Section */}
            <div className="border-t pt-4">
              <label className="text-sm font-semibold mb-2 block">üìÅ Media Attachments (Optional)</label>
              <p className="text-xs text-muted-foreground mb-3">
                Attach images, videos, or PDF files for workflow analysis. (Max {MAX_FILE_SIZE_MB}MB)
              </p>

              {/* Upload Button */}
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleMediaUpload}
                accept={SUPPORTED_MEDIA_TYPES.join(',')}
                className="hidden"
              />
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full mb-3"
              >
                {isUploading ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Uploading... {uploadProgress}%
                  </>
                ) : (
                  <>
                    <Upload className="w-4 h-4 mr-2" />
                    Attach File
                  </>
                )}
              </Button>

              {/* Uploaded Files List */}
              {uploadedMedia.length > 0 && (
                <div className="space-y-2">
                  {uploadedMedia.map((media, index) => (
                    <div
                      key={`${media.filename}-${index}`}
                      className="flex items-center justify-between p-2 bg-secondary rounded-md text-sm"
                    >
                      <div className="flex items-center gap-2 overflow-hidden">
                        {getMediaIcon(media.content_type)}
                        <span className="truncate max-w-[200px]" title={media.filename}>
                          {media.filename}
                        </span>
                        <span className="text-xs text-muted-foreground whitespace-nowrap">
                          ({(media.size_bytes / 1024 / 1024).toFixed(1)}MB)
                        </span>
                      </div>
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => handleRemoveMedia(index)}
                        className="h-6 w-6 p-0 hover:bg-destructive/20"
                      >
                        <X className="w-4 h-4" />
                      </Button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleInitialStateCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleInitialStateConfirm} className="bg-primary hover:bg-primary/90">Run</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 5. Clone Instructions Dialog (ÏÉàÎ°ú Ï∂îÍ∞ÄÎê®) */}
      <CloneInstructionsDialog
        open={showCloneDialog}
        onOpenChange={setShowCloneDialog}
        workflows={workflows}
        onConfirm={handleCloneConfirm}
        isCloning={isCloningInstructions}
        targetWorkflowName={savedWorkflowName}
        targetWorkflowId={savedWorkflowId}
      />

      {/* 6. Plan Briefing Modal */}
      <PlanBriefingModal
        open={briefingOpen}
        onOpenChange={setBriefingOpen}
        briefing={planBriefing.briefing}
        loading={planBriefing.isLoading}
        onConfirm={() => {
          setBriefingOpen(false);
          toast.info('Use "Run Workflow" to execute');
        }}
        onCancel={() => setBriefingOpen(false)}
      />
    </div>
  );
};
